\doxysection{deps/catch/catch\+\_\+amalgamated.cpp File Reference}
\hypertarget{catch__amalgamated_8cpp}{}\label{catch__amalgamated_8cpp}\index{deps/catch/catch\_amalgamated.cpp@{deps/catch/catch\_amalgamated.cpp}}
{\ttfamily \#include "{}catch\+\_\+amalgamated.\+hpp"{}}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include $<$limits$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include $<$cassert$>$}\newline
{\ttfamily \#include $<$stack$>$}\newline
{\ttfamily \#include $<$exception$>$}\newline
{\ttfamily \#include $<$algorithm$>$}\newline
{\ttfamily \#include $<$iomanip$>$}\newline
{\ttfamily \#include $<$set$>$}\newline
{\ttfamily \#include $<$cctype$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$ostream$>$}\newline
{\ttfamily \#include $<$chrono$>$}\newline
{\ttfamily \#include $<$random$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$stdexcept$>$}\newline
{\ttfamily \#include $<$cerrno$>$}\newline
{\ttfamily \#include $<$signal.\+h$>$}\newline
{\ttfamily \#include $<$cstring$>$}\newline
{\ttfamily \#include $<$cstdlib$>$}\newline
{\ttfamily \#include $<$cstdio$>$}\newline
{\ttfamily \#include $<$sstream$>$}\newline
{\ttfamily \#include $<$iosfwd$>$}\newline
{\ttfamily \#include $<$ctime$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$iterator$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$regex$>$}\newline
{\ttfamily \#include $<$cfloat$>$}\newline
{\ttfamily \#include $<$map$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structCatch_1_1Generators_1_1RandomFloatingGenerator_1_1PImpl}{Catch\+::\+Generators\+::\+Random\+Floating\+Generator\+::\+PImpl}}
\item 
struct \mbox{\hyperlink{structCatch_1_1SignalDefs}{Catch\+::\+Signal\+Defs}}
\item 
struct \mbox{\hyperlink{structCatch_1_1ReporterRegistry_1_1ReporterRegistryImpl}{Catch\+::\+Reporter\+Registry\+::\+Reporter\+Registry\+Impl}}
\item 
struct \mbox{\hyperlink{structCatch_1_1StringStreams}{Catch\+::\+String\+Streams}}
\item 
struct \mbox{\hyperlink{structCatch_1_1ColumnInfo}{Catch\+::\+Column\+Info}}
\item 
class \mbox{\hyperlink{classCatch_1_1TablePrinter}{Catch\+::\+Table\+Printer}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceCatch}{Catch}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Benchmark}{Catch\+::\+Benchmark}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail}{Catch\+::\+Benchmark\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1literals}{Catch\+::literals}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Detail}{Catch\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Generators}{Catch\+::\+Generators}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Generators_1_1Detail}{Catch\+::\+Generators\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Clara}{Catch\+::\+Clara}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Clara_1_1Detail}{Catch\+::\+Clara\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1TestCaseTracking}{Catch\+::\+Test\+Case\+Tracking}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1TextFlow}{Catch\+::\+Text\+Flow}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Matchers}{Catch\+::\+Matchers}}
\item 
namespace \mbox{\hyperlink{namespaceCatch_1_1Matchers_1_1Detail}{Catch\+::\+Matchers\+::\+Detail}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}(\mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{namespaceCatch_aa5d4bbf2380d3781343c4eefcb3456b9}{Catch\+::\+Registry\+Hub\+Singleton}} = Singleton$<$Registry\+Hub, \mbox{\hyperlink{classCatch_1_1IRegistryHub}{IRegistry\+Hub}}, \mbox{\hyperlink{classCatch_1_1IMutableRegistryHub}{IMutable\+Registry\+Hub}}$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \mbox{\hyperlink{namespaceCatch_1_1Matchers_1_1Detail_a65dcb4c6cc6803847848523398ae680c}{Catch\+::\+Matchers\+::\+Detail\+::\+Floating\+Point\+Kind}} \+: uint8\+\_\+t \{ \mbox{\hyperlink{namespaceCatch_1_1Matchers_1_1Detail_a65dcb4c6cc6803847848523398ae680ca22ae0e2b89e5e3d477f988cc36d3272b}{Catch\+::\+Matchers\+::\+Detail\+::\+Float}}
, \mbox{\hyperlink{namespaceCatch_1_1Matchers_1_1Detail_a65dcb4c6cc6803847848523398ae680cad909d38d705ce75386dd86e611a82f5b}{Catch\+::\+Matchers\+::\+Detail\+::\+Double}}
 \}
\item 
enum class \mbox{\hyperlink{namespaceCatch_a1d4a723904a65baf5f366136cd752d06}{Catch\+::\+Justification}} \+: uint8\+\_\+t \{ \mbox{\hyperlink{namespaceCatch_a1d4a723904a65baf5f366136cd752d06a945d5e233cf7d6240f6b783b36a374ff}{Catch\+::\+Left}}
, \mbox{\hyperlink{namespaceCatch_a1d4a723904a65baf5f366136cd752d06a92b09c7c48c520c3c55e497875da437c}{Catch\+::\+Right}}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (\mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}}$<$ 6.\+250000)
\item 
double \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_a571030d8a3068b49d454220cfdea714f}{Catch\+::\+Benchmark\+::\+Detail\+::weighted\+\_\+average\+\_\+quantile}} (int k, int q, double \texorpdfstring{$\ast$}{*}first, double \texorpdfstring{$\ast$}{*}last)
\item 
\mbox{\hyperlink{structCatch_1_1Benchmark_1_1OutlierClassification}{Outlier\+Classification}} \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_a523468c0e7dbf99ffb1801aad78e352d}{Catch\+::\+Benchmark\+::\+Detail\+::classify\+\_\+outliers}} (double const \texorpdfstring{$\ast$}{*}first, double const \texorpdfstring{$\ast$}{*}last)
\item 
double \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_ac5f830d662344dd75387c26aa83e6ac3}{Catch\+::\+Benchmark\+::\+Detail\+::mean}} (double const \texorpdfstring{$\ast$}{*}first, double const \texorpdfstring{$\ast$}{*}last)
\item 
double \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_abc5e70b0f758f550b2fdff85512efdb5}{Catch\+::\+Benchmark\+::\+Detail\+::normal\+\_\+cdf}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}})
\item 
double \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_a62d6c634e2c8901d02ffe8718817f1b4}{Catch\+::\+Benchmark\+::\+Detail\+::erfc\+\_\+inv}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}})
\item 
double \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_af3527090cdeb0456b1aacbdc29050841}{Catch\+::\+Benchmark\+::\+Detail\+::normal\+\_\+quantile}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}})
\item 
\mbox{\hyperlink{structCatch_1_1Benchmark_1_1Estimate}{Estimate}}$<$ double $>$ \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_a0a635ce60c227f5217d9606e2afe527c}{Catch\+::\+Benchmark\+::\+Detail\+::bootstrap}} (double confidence\+\_\+level, double \texorpdfstring{$\ast$}{*}first, double \texorpdfstring{$\ast$}{*}last, \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_ad7bb71eb022618e4a57e3378f5d70b13}{sample}} const \&resample, double(\texorpdfstring{$\ast$}{*}estimator)(double const \texorpdfstring{$\ast$}{*}, double const \texorpdfstring{$\ast$}{*}))
\item 
\mbox{\hyperlink{structCatch_1_1Benchmark_1_1Detail_1_1bootstrap__analysis}{bootstrap\+\_\+analysis}} \mbox{\hyperlink{namespaceCatch_1_1Benchmark_1_1Detail_a1a4ae7ccc7fa8c996bc6e4ada5a7004b}{Catch\+::\+Benchmark\+::\+Detail\+::analyse\+\_\+samples}} (double confidence\+\_\+level, unsigned int n\+\_\+resamples, double \texorpdfstring{$\ast$}{*}first, double \texorpdfstring{$\ast$}{*}last)
\item 
\mbox{\hyperlink{classCatch_1_1Approx}{Approx}} \mbox{\hyperlink{namespaceCatch_1_1literals_af610e11bcfe94ebc07788fdcf1b716b7}{Catch\+::literals\+::operator"{}"{}\+\_\+a}} (long double val)
\item 
\mbox{\hyperlink{classCatch_1_1Approx}{Approx}} \mbox{\hyperlink{namespaceCatch_1_1literals_ad9c310bd2eaacfd7c23f7a5a1fc587bf}{Catch\+::literals\+::operator"{}"{}\+\_\+a}} (unsigned long long val)
\item 
bool \mbox{\hyperlink{namespaceCatch_a2842e594466b16b9ca13e09077b44406}{Catch\+::operator==}} (\mbox{\hyperlink{structCatch_1_1ProcessedReporterSpec}{Processed\+Reporter\+Spec}} const \&lhs, \mbox{\hyperlink{structCatch_1_1ProcessedReporterSpec}{Processed\+Reporter\+Spec}} const \&rhs)
\item 
std\+::uint32\+\_\+t \mbox{\hyperlink{namespaceCatch_aba921d5844aa120874480fe71d1c1ae3}{Catch\+::get\+Seed}} ()
\begin{DoxyCompactList}\small\item\em Returns Catch2\textquotesingle{}s current RNG seed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classCatch_1_1IRegistryHub}{IRegistry\+Hub}} const \& \mbox{\hyperlink{namespaceCatch_a5d328566cb8da87b48f1fac3f319ac7a}{Catch\+::get\+Registry\+Hub}} ()
\item 
\mbox{\hyperlink{classCatch_1_1IMutableRegistryHub}{IMutable\+Registry\+Hub}} \& \mbox{\hyperlink{namespaceCatch_a585459763f2c7610e57de2dd22dd1ad8}{Catch\+::get\+Mutable\+Registry\+Hub}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_a0f78e9afdebc6d4512d18e76fbf54b8c}{Catch\+::clean\+Up}} ()
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_adafff91485eeeeb9e9333f317cc0e3b1}{Catch\+::translate\+Active\+Exception}} ()
\item 
bool \mbox{\hyperlink{namespaceCatch_ad31a3e3a246a7ae3b28d62db42ad5837}{Catch\+::operator$<$}} (\mbox{\hyperlink{structCatch_1_1Tag}{Tag}} const \&lhs, \mbox{\hyperlink{structCatch_1_1Tag}{Tag}} const \&rhs)
\item 
bool \mbox{\hyperlink{namespaceCatch_a757e5758cf4ec14df26ff166f3db43ab}{Catch\+::operator==}} (\mbox{\hyperlink{structCatch_1_1Tag}{Tag}} const \&lhs, \mbox{\hyperlink{structCatch_1_1Tag}{Tag}} const \&rhs)
\item 
\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{Test\+Case\+Info}} $>$ \mbox{\hyperlink{namespaceCatch_ac0bff8ed2ec530c293ad520bf2ce7075}{Catch\+::make\+Test\+Case\+Info}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} \+\_\+class\+Name, \mbox{\hyperlink{structCatch_1_1NameAndTags}{Name\+And\+Tags}} const \&name\+And\+Tags, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{Source\+Line\+Info}} const \&\+\_\+line\+Info)
\item 
bool \mbox{\hyperlink{namespaceCatch_ab9aaac3d0fbc3b4b371541fd21ffb8ad}{Catch\+::operator$<$}} (\mbox{\hyperlink{structCatch_1_1TestCaseInfo}{Test\+Case\+Info}} const \&lhs, \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{Test\+Case\+Info}} const \&rhs)
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_1_1Detail_a23bdcac0ef138b222c3747e2af979e9a}{Catch\+::\+Detail\+::convert\+Into\+String}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} string, bool escape\+Invisibles)
\begin{DoxyCompactList}\small\item\em Encases \`{}string in quotes, and optionally escapes invisibles. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceCatch_1_1Detail_a0dc4241ab150d3d8e1d0a3d30c781c39}{Catch\+::\+Detail\+::convert\+Into\+String}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} string)
\begin{DoxyCompactList}\small\item\em Encases {\ttfamily string} in quotes, and escapes invisibles if user requested it via CLI. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceCatch_1_1Detail_ac5d6c510e565ee5bddcc2236194ce29e}{Catch\+::\+Detail\+::raw\+Memory\+To\+String}} (const void \texorpdfstring{$\ast$}{*}object, std\+::size\+\_\+t size)
\item 
void \mbox{\hyperlink{namespaceCatch_1_1Detail_a60f033a91680546a152f5dfa4427104c}{Catch\+::\+Detail\+::register\+Translator\+Impl}} (\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{classCatch_1_1IExceptionTranslator}{IException\+Translator}} $>$ \&\&translator)
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_aa7e8f5954fada348761e0473b3e4c1a2}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{structCatch_1_1Version}{Version}} const \&version)
\item 
\mbox{\hyperlink{structCatch_1_1Version}{Version}} const \& \mbox{\hyperlink{namespaceCatch_a35e54475ed669ef7f7ac00b858e91b2a}{Catch\+::library\+Version}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_1_1Generators_1_1Detail_ab6e4736f7a2b0501a13c4dc4adfe5bb6}{Catch\+::\+Generators\+::\+Detail\+::throw\+\_\+generator\+\_\+exception}} (char const \texorpdfstring{$\ast$}{*}msg)
\begin{DoxyCompactList}\small\item\em Throws \doxylink{classCatch_1_1GeneratorException}{Generator\+Exception} with the provided message. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classCatch_1_1IGeneratorTracker}{IGenerator\+Tracker}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceCatch_1_1Generators_ab0ad55177ac1e5f00b123909b191f436}{Catch\+::\+Generators\+::acquire\+Generator\+Tracker}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} generator\+Name, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{Source\+Line\+Info}} const \&line\+Info)
\item 
\mbox{\hyperlink{classCatch_1_1IGeneratorTracker}{IGenerator\+Tracker}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceCatch_1_1Generators_a24e1bac2be5e078f26c395a96470b706}{Catch\+::\+Generators\+::create\+Generator\+Tracker}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} generator\+Name, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{Source\+Line\+Info}} line\+Info, \mbox{\hyperlink{namespaceCatch_1_1Generators_aa9dc8fef28828fe351480d5be7bb287d}{Generator\+Base\+Ptr}} \&\&generator)
\item 
std\+::uint32\+\_\+t \mbox{\hyperlink{namespaceCatch_1_1Generators_1_1Detail_a43ff3ca07ca525084cadb89dee13e39e}{Catch\+::\+Generators\+::\+Detail\+::get\+Seed}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_a26cdeefafe46a4d606b51248eb7bbe7e}{Catch\+::handle\+Exception\+Match\+Expr}} (\mbox{\hyperlink{classCatch_1_1AssertionHandler}{Assertion\+Handler}} \&handler, std\+::string const \&str)
\item 
\mbox{\hyperlink{namespaceCatch_1_1Clara_1_1Detail_a6822080555d7f8f7fb6f8149c7819c42}{Parser\+Result}} \mbox{\hyperlink{namespaceCatch_1_1Clara_1_1Detail_ab5b76a1843c33a4a71aa698a3defc528}{Catch\+::\+Clara\+::\+Detail\+::convert\+Into}} (std\+::string const \&source, std\+::string \&target)
\item 
\mbox{\hyperlink{namespaceCatch_1_1Clara_1_1Detail_a6822080555d7f8f7fb6f8149c7819c42}{Parser\+Result}} \mbox{\hyperlink{namespaceCatch_1_1Clara_1_1Detail_aaf5cc67b22b463d47af6e69ee31bf44e}{Catch\+::\+Clara\+::\+Detail\+::convert\+Into}} (std\+::string const \&source, bool \&target)
\item 
\mbox{\hyperlink{classCatch_1_1Clara_1_1Parser}{Clara\+::\+Parser}} \mbox{\hyperlink{namespaceCatch_a96d773398ae9697da7845bbf5027e35e}{Catch\+::make\+Command\+Line\+Parser}} (\mbox{\hyperlink{structCatch_1_1ConfigData}{Config\+Data}} \&config)
\item 
\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ Colour\+Impl $>$ \mbox{\hyperlink{namespaceCatch_a66d288723373b192f025a2f4ed2f3f11}{Catch\+::make\+Colour\+Impl}} (\mbox{\hyperlink{namespaceCatch_a91308e87521e370e591065a22b010025}{Colour\+Mode}} colour\+Selection, IStream \texorpdfstring{$\ast$}{*}stream)
\item 
bool \mbox{\hyperlink{namespaceCatch_a76a7aa70b229be45ef1eec1d5ca8d87c}{Catch\+::is\+Colour\+Impl\+Available}} (\mbox{\hyperlink{namespaceCatch_a91308e87521e370e591065a22b010025}{Colour\+Mode}} colour\+Selection)
\item 
void \mbox{\hyperlink{namespaceCatch_ae50508f10ffc4ed873a31a4db4caea16}{Catch\+::clean\+Up\+Context}} ()
\item 
\mbox{\hyperlink{classCatch_1_1Context}{Context}} \& \mbox{\hyperlink{namespaceCatch_aeb5fab7ca94d3e959fd7db6167caf5ee}{Catch\+::get\+Current\+Mutable\+Context}} ()
\item 
\mbox{\hyperlink{classCatch_1_1SimplePcg32}{Simple\+Pcg32}} \& \mbox{\hyperlink{namespaceCatch_a95e86995bfdce76fca887634094ef2e9}{Catch\+::shared\+Rng}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_aa5dcf4750ce9a854f4b74d3c952d13cc}{Catch\+::write\+To\+Debug\+Console}} (std\+::string const \&text)
\item 
bool \mbox{\hyperlink{namespaceCatch_ab079497368fb1df25af39ad494d2a241}{Catch\+::is\+Debugger\+Active}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_a520110c31f26cf9892595772ab814fc0}{Catch\+::format\+Reconstructed\+Expression}} (std\+::ostream \&os, std\+::string const \&lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} op, std\+::string const \&rhs)
\item 
void \mbox{\hyperlink{namespaceCatch_a3cbceeab9252d1b752f66a2826e92548}{Catch\+::throw\+\_\+exception}} (std\+::exception const \&e)
\item 
void \mbox{\hyperlink{namespaceCatch_a707884e681203fef6bf7dbf752532fa5}{Catch\+::throw\+\_\+logic\+\_\+error}} (std\+::string const \&msg)
\item 
void \mbox{\hyperlink{namespaceCatch_ae67297c3e265b0fcd55de371bf408e4e}{Catch\+::throw\+\_\+domain\+\_\+error}} (std\+::string const \&msg)
\item 
void \mbox{\hyperlink{namespaceCatch_a48d2c35022dd9d56a1b7ee78ad581eea}{Catch\+::throw\+\_\+runtime\+\_\+error}} (std\+::string const \&msg)
\item 
std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} $>$ \mbox{\hyperlink{namespaceCatch_1_1Detail_a4e0e09e87f561af2d3a881b209a9a481}{Catch\+::\+Detail\+::parse\+Enums}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} enums)
\item 
\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{structCatch_1_1Detail_1_1EnumInfo}{Enum\+Info}} $>$ \mbox{\hyperlink{namespaceCatch_1_1Detail_a4f0c01d00fa6af891eb82fcf9baaf95c}{Catch\+::\+Detail\+::make\+Enum\+Info}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} enum\+Name, \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} all\+Value\+Names, std\+::vector$<$ int $>$ const \&values)
\item 
uint32\+\_\+t \mbox{\hyperlink{namespaceCatch_1_1Detail_ade51091dea188100d1c7a8acc55f5ea5}{Catch\+::\+Detail\+::convert\+To\+Bits}} (float f)
\item 
uint64\+\_\+t \mbox{\hyperlink{namespaceCatch_1_1Detail_aa4cbea1ca1087603043d57005bbbec54}{Catch\+::\+Detail\+::convert\+To\+Bits}} (double d)
\item 
bool \mbox{\hyperlink{namespaceCatch_1_1Detail_a18fef8312d01399bbf5722432f099216}{Catch\+::\+Detail\+::direct\+Compare}} (float lhs, float rhs)
\item 
bool \mbox{\hyperlink{namespaceCatch_1_1Detail_a4e6b189b0908b0866a4f79b5ba5f9b7d}{Catch\+::\+Detail\+::direct\+Compare}} (double lhs, double rhs)
\item 
char const \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceCatch_1_1Detail_a9a53cd3f44546dfc2935a3a6d3277ce6}{Catch\+::\+Detail\+::get\+Env}} (char const \texorpdfstring{$\ast$}{*}var\+Name)
\item 
auto \mbox{\hyperlink{namespaceCatch_a375b927ff7cc5356ff4a71626d54c83f}{Catch\+::make\+Stream}} (std\+::string const \&filename) -\/$>$ \mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ IStream $>$
\item 
auto \mbox{\hyperlink{namespaceCatch_abf821d46e662c8d93d80a98d79a10314}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{classCatch_1_1LazyExpression}{Lazy\+Expression}} const \&lazy\+Expr) -\/$>$ std\+::ostream \&
\item 
bool \mbox{\hyperlink{namespaceCatch_a11c40de0d3593160a350d9e4323311b2}{Catch\+::list}} (IEvent\+Listener \&reporter, \mbox{\hyperlink{classCatch_1_1Config}{Config}} const \&config)
\item 
int \mbox{\hyperlink{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}} (int argc, char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]})
\item 
bool \mbox{\hyperlink{namespaceCatch_a73b1b55bbb03be501419181d88db9c6f}{Catch\+::is\+Redirect\+Available}} (Output\+Redirect\+::\+Kind kind)
\item 
\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ Output\+Redirect $>$ \mbox{\hyperlink{namespaceCatch_ae9831933e640b35f907975c129f4763f}{Catch\+::make\+Output\+Redirect}} (bool actual)
\item 
Redirect\+Guard \mbox{\hyperlink{namespaceCatch_a6869418a3394de1080b85a72d73b37e2}{Catch\+::scoped\+Activate}} (Output\+Redirect \&redirect\+Impl)
\item 
Redirect\+Guard \mbox{\hyperlink{namespaceCatch_a604293e8cd25e37091594d6f30c5f54e}{Catch\+::scoped\+Deactivate}} (Output\+Redirect \&redirect\+Impl)
\item 
\mbox{\hyperlink{classCatch_1_1Optional}{Optional}}$<$ unsigned int $>$ \mbox{\hyperlink{namespaceCatch_a369d3d53347e3c8da1d23ef64fa39daf}{Catch\+::parse\+UInt}} (std\+::string const \&input, int base)
\item 
bool \mbox{\hyperlink{namespaceCatch_aff37796f0f578c2816f74267e641c5f7}{Catch\+::isnan}} (float f)
\item 
bool \mbox{\hyperlink{namespaceCatch_a37d450336c237ac77721f0a3f9fb048d}{Catch\+::isnan}} (double d)
\item 
float \mbox{\hyperlink{namespaceCatch_ae65d074e6c60320640a500d302b83bb2}{Catch\+::nextafter}} (float \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, float y)
\item 
double \mbox{\hyperlink{namespaceCatch_add39a699bce7f13c95616fcaa62ab7ca}{Catch\+::nextafter}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, double y)
\item 
bool \mbox{\hyperlink{namespaceCatch_a6d5126d3ec2d72a47fa404b704d99010}{Catch\+::operator==}} (\mbox{\hyperlink{classCatch_1_1SimplePcg32}{Simple\+Pcg32}} const \&lhs, \mbox{\hyperlink{classCatch_1_1SimplePcg32}{Simple\+Pcg32}} const \&rhs)
\item 
bool \mbox{\hyperlink{namespaceCatch_ab5a7a360e947e33298ee18f652749230}{Catch\+::operator!=}} (\mbox{\hyperlink{classCatch_1_1SimplePcg32}{Simple\+Pcg32}} const \&lhs, \mbox{\hyperlink{classCatch_1_1SimplePcg32}{Simple\+Pcg32}} const \&rhs)
\item 
std\+::uint32\+\_\+t \mbox{\hyperlink{namespaceCatch_a170bbe5db76570c4820b5e2eb260f82b}{Catch\+::generate\+Random\+Seed}} (\mbox{\hyperlink{namespaceCatch_a0e8d3a1107ecbaa1943e0a462db99a3d}{Generate\+From}} from)
\item 
std\+::vector$<$ std\+::string $>$ \mbox{\hyperlink{namespaceCatch_1_1Detail_a874fd7848ec5a0ef02d88c6ec37c9a03}{Catch\+::\+Detail\+::split\+Reporter\+Spec}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} reporter\+Spec)
\begin{DoxyCompactList}\small\item\em Splits the reporter spec into reporter name and kv-\/pair options. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classCatch_1_1Optional}{Optional}}$<$ \mbox{\hyperlink{namespaceCatch_a91308e87521e370e591065a22b010025}{Colour\+Mode}} $>$ \mbox{\hyperlink{namespaceCatch_1_1Detail_a64ba838a0c2e6767d095a7a01fc07b48}{Catch\+::\+Detail\+::string\+To\+Colour\+Mode}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} colour\+Mode)
\item 
bool \mbox{\hyperlink{namespaceCatch_a408299b05a1363c7cd99fb5b6c7f1e3d}{Catch\+::operator==}} (\mbox{\hyperlink{classCatch_1_1ReporterSpec}{Reporter\+Spec}} const \&lhs, \mbox{\hyperlink{classCatch_1_1ReporterSpec}{Reporter\+Spec}} const \&rhs)
\item 
\mbox{\hyperlink{classCatch_1_1Optional}{Optional}}$<$ \mbox{\hyperlink{classCatch_1_1ReporterSpec}{Reporter\+Spec}} $>$ \mbox{\hyperlink{namespaceCatch_ae987bd04fd59321f5183794daeffd4cf}{Catch\+::parse\+Reporter\+Spec}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} reporter\+Spec)
\item 
\mbox{\hyperlink{classCatch_1_1IResultCapture}{IResult\+Capture}} \& \mbox{\hyperlink{namespaceCatch_af718eeab870712f292ed8dc6ee3f6488}{Catch\+::get\+Result\+Capture}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_a161400810eb0995394d6d8d3cae821ad}{Catch\+::seed\+Rng}} (\mbox{\hyperlink{classCatch_1_1IConfig}{IConfig}} const \&config)
\item 
unsigned int \mbox{\hyperlink{namespaceCatch_acf5ea05e942d2d7fe79111e12754ed76}{Catch\+::rng\+Seed}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_a788ebefcd83342b7c479222a1eeffaee}{Catch\+::add\+Singleton}} (ISingleton \texorpdfstring{$\ast$}{*}singleton)
\item 
void \mbox{\hyperlink{namespaceCatch_a8bdb92cb53a4e016bc0dee66efd99118}{Catch\+::cleanup\+Singletons}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a8c8ea1f66bc1cdc3e1254ed7fa57c06d}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{Source\+Line\+Info}} const \&info)
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a0179d453617ba2296f2baa99a49e7264}{Catch\+::cout}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a54c1ce08041448d684ae8edc14162cd2}{Catch\+::cerr}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a1b2213f54e4d31a659db49827e81856b}{Catch\+::clog}} ()
\item 
bool \mbox{\hyperlink{namespaceCatch_a695f62327be0676e046291eeaae15110}{Catch\+::starts\+With}} (std\+::string const \&s, std\+::string const \&prefix)
\item 
bool \mbox{\hyperlink{namespaceCatch_aa77a782fac38c4f6417a7af909e8b29c}{Catch\+::starts\+With}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} s, char prefix)
\item 
bool \mbox{\hyperlink{namespaceCatch_ada025504f627feaf9ac68ca391515dff}{Catch\+::ends\+With}} (std\+::string const \&s, std\+::string const \&suffix)
\item 
bool \mbox{\hyperlink{namespaceCatch_afd801a3e33fd7a8b91ded0d02747a93f}{Catch\+::ends\+With}} (std\+::string const \&s, char suffix)
\item 
bool \mbox{\hyperlink{namespaceCatch_aa52974b0e426e7e2fbd725a900e9c36e}{Catch\+::contains}} (std\+::string const \&s, std\+::string const \&infix)
\item 
void \mbox{\hyperlink{namespaceCatch_a0760dbe87d090a55a35414db57d272c4}{Catch\+::to\+Lower\+In\+Place}} (std\+::string \&s)
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_ac036a17412d318598ffda8e1fe7a1177}{Catch\+::to\+Lower}} (std\+::string const \&s)
\item 
char \mbox{\hyperlink{namespaceCatch_ad2b13ec5c5220e066b6fe7ba7a82db9d}{Catch\+::to\+Lower}} (char c)
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_a084108b47f37d8bfd5db51c50c7451b3}{Catch\+::trim}} (std\+::string const \&str)
\item 
\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} \mbox{\hyperlink{namespaceCatch_a6f6d8ef0349688290bd242b50a702c28}{Catch\+::trim}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} ref)
\item 
bool \mbox{\hyperlink{namespaceCatch_afe4e6770da547e43e9e4eeaa05f946ea}{Catch\+::replace\+In\+Place}} (std\+::string \&str, std\+::string const \&replace\+This, std\+::string const \&with\+This)
\item 
std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} $>$ \mbox{\hyperlink{namespaceCatch_a678e3c779388970bb3ec5802245f93d7}{Catch\+::split\+String\+Ref}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} str, char delimiter)
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a27d46b1ac4a1956660e4e9361c4835b8}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, pluralise const \&pluraliser)
\item 
auto \mbox{\hyperlink{namespaceCatch_acabbdedb64bd66b7e0233969f6cdfb58}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} str) -\/$>$ std\+::ostream \&
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_ae053e7e198e60bf45f2b8bc51050f5f4}{Catch\+::operator+}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} rhs)
\item 
auto \mbox{\hyperlink{namespaceCatch_a1c519834d917d9c6d2df64f26abcf059}{Catch\+::operator+=}} (std\+::string \&lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} rhs) -\/$>$ std\+::string \&
\item 
std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} $>$ \mbox{\hyperlink{namespaceCatch_ad9dc14789e42b18c6dc26590a49a6eaa}{Catch\+::sort\+Tests}} (\mbox{\hyperlink{classCatch_1_1IConfig}{IConfig}} const \&config, std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} $>$ const \&unsorted\+Test\+Cases)
\item 
bool \mbox{\hyperlink{namespaceCatch_a12f76a88f2882e9d1d221979dec0324d}{Catch\+::is\+Throw\+Safe}} (\mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} const \&test\+Case, \mbox{\hyperlink{classCatch_1_1IConfig}{IConfig}} const \&config)
\item 
std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} $>$ \mbox{\hyperlink{namespaceCatch_af1944a358b260e03c6695aa7ae259c9a}{Catch\+::filter\+Tests}} (std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} $>$ const \&test\+Cases, \mbox{\hyperlink{classCatch_1_1TestSpec}{Test\+Spec}} const \&test\+Spec, \mbox{\hyperlink{classCatch_1_1IConfig}{IConfig}} const \&config)
\item 
std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} $>$ const \& \mbox{\hyperlink{namespaceCatch_aae7d61b3abc9c8d3c82407b380e6a414}{Catch\+::get\+All\+Test\+Cases\+Sorted}} (\mbox{\hyperlink{classCatch_1_1IConfig}{IConfig}} const \&config)
\item 
void \mbox{\hyperlink{namespaceCatch_a2236988eae84fb6bcc456bbf8ddfd2bf}{Catch\+::throw\+\_\+test\+\_\+failure\+\_\+exception}} ()
\item 
void \mbox{\hyperlink{namespaceCatch_a7c6db2bf035e2e570d0b6703f6f5a3d8}{Catch\+::throw\+\_\+test\+\_\+skip\+\_\+exception}} ()
\item 
\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{classCatch_1_1ITestInvoker}{ITest\+Invoker}} $>$ \mbox{\hyperlink{namespaceCatch_a4036958fd61b3ba0b3d2467e7f4f6fd7}{Catch\+::make\+Test\+Invoker}} (void(\texorpdfstring{$\ast$}{*}test\+As\+Function)())
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_1_1TextFlow_a512213886b4304e4573b57fe42b66d4e}{Catch\+::\+Text\+Flow\+::operator$<$$<$}} (std\+::ostream \&os, Column const \&col)
\item 
Column \mbox{\hyperlink{namespaceCatch_1_1TextFlow_a24f631f4606e5664e764e6a6b9df5c04}{Catch\+::\+Text\+Flow\+::\+Spacer}} (size\+\_\+t space\+Width)
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_1_1TextFlow_a2627582ff1b81131b3deac691e847156}{Catch\+::\+Text\+Flow\+::operator$<$$<$}} (std\+::ostream \&os, Columns const \&cols)
\item 
Columns \mbox{\hyperlink{namespaceCatch_1_1TextFlow_a3027b08d3fce163c060fbeb52520d28a}{Catch\+::\+Text\+Flow\+::operator+}} (Column const \&lhs, Column const \&rhs)
\item 
Columns \mbox{\hyperlink{namespaceCatch_1_1TextFlow_a3fe83f06ebecb334bd138dae8568ad29}{Catch\+::\+Text\+Flow\+::operator+}} (Column \&\&lhs, Column \&\&rhs)
\item 
Columns \& \mbox{\hyperlink{namespaceCatch_1_1TextFlow_a12526387d93de04a83f5842cefb83d92}{Catch\+::\+Text\+Flow\+::operator+=}} (Columns \&lhs, Column const \&rhs)
\item 
Columns \& \mbox{\hyperlink{namespaceCatch_1_1TextFlow_ae7ff2aeae98d2bb38fd08399bb7da352}{Catch\+::\+Text\+Flow\+::operator+=}} (Columns \&lhs, Column \&\&rhs)
\item 
Columns \mbox{\hyperlink{namespaceCatch_1_1TextFlow_addb58348d617cfd289663fe52c185e68}{Catch\+::\+Text\+Flow\+::operator+}} (Columns const \&lhs, Column const \&rhs)
\item 
Columns \mbox{\hyperlink{namespaceCatch_1_1TextFlow_aa8b32803ded290301e4ec200e138c541}{Catch\+::\+Text\+Flow\+::operator+}} (Columns \&\&lhs, Column \&\&rhs)
\item 
bool \mbox{\hyperlink{namespaceCatch_a4b5a2b34a00e65b753185bbc6a4962be}{Catch\+::uncaught\+\_\+exceptions}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a64142d8bbd7638d9af0e6b6829821e86}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, Xml\+Encode const \&xml\+Encode)
\item 
Is\+Empty\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_ae345560f84f68d52fc5df4ac77eb4b92}{Catch\+::\+Matchers\+::\+Is\+Empty}} ()
\item 
Has\+Size\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a640c1714c014191cc131b37f955f83ed}{Catch\+::\+Matchers\+::\+Size\+Is}} (std\+::size\+\_\+t sz)
\item 
Exception\+Message\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a4c7d45a32d4ecf1d71b24b37920a5be7}{Catch\+::\+Matchers\+::\+Message}} (std\+::string const \&message)
\item 
Within\+Ulps\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a88361ad809aab09ff75c87bf6cdd7fad}{Catch\+::\+Matchers\+::\+Within\+ULP}} (double target, uint64\+\_\+t max\+Ulp\+Diff)
\item 
Within\+Ulps\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_af0eb912b197be0f79e60fd1884e9ac29}{Catch\+::\+Matchers\+::\+Within\+ULP}} (float target, uint64\+\_\+t max\+Ulp\+Diff)
\item 
Within\+Abs\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a13a915665906ab3efb39e118c649285f}{Catch\+::\+Matchers\+::\+Within\+Abs}} (double target, double margin)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a78dba3ba1112c48a6376a38b48ea70e2}{Catch\+::\+Matchers\+::\+Within\+Rel}} (double target, double eps)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a01c32f9483573cfb0d703f5f34b9848d}{Catch\+::\+Matchers\+::\+Within\+Rel}} (double target)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a65b303b8eb9ba612cc5c149488aa7753}{Catch\+::\+Matchers\+::\+Within\+Rel}} (float target, float eps)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a735b5278dad4189adbc79098c2360b03}{Catch\+::\+Matchers\+::\+Within\+Rel}} (float target)
\item 
Is\+Na\+NMatcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a0d170fa146d9a4ec0d908acce010128e}{Catch\+::\+Matchers\+::\+Is\+NaN}} ()
\item 
All\+True\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a4f719bca42718f4936668308772732ae}{Catch\+::\+Matchers\+::\+All\+True}} ()
\item 
None\+True\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a072ee44afcb1647b55b6c3437f22af44}{Catch\+::\+Matchers\+::\+None\+True}} ()
\item 
Any\+True\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a99b3d0b547a4335b786e8fcea6a11cad}{Catch\+::\+Matchers\+::\+Any\+True}} ()
\item 
String\+Equals\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_ae584743abef84739c036faf46eef53b7}{Catch\+::\+Matchers\+::\+Equals}} (std\+::string const \&str, \mbox{\hyperlink{namespaceCatch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
String\+Contains\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a348b90347a2dea3747eabd01d03c114c}{Catch\+::\+Matchers\+::\+Contains\+Substring}} (std\+::string const \&str, \mbox{\hyperlink{namespaceCatch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
Ends\+With\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_a12b1480cb0af61579e8776cf538d0069}{Catch\+::\+Matchers\+::\+Ends\+With}} (std\+::string const \&str, \mbox{\hyperlink{namespaceCatch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
Starts\+With\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_af3c7edfbfb4cba59f76578304597e548}{Catch\+::\+Matchers\+::\+Starts\+With}} (std\+::string const \&str, \mbox{\hyperlink{namespaceCatch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
Regex\+Matcher \mbox{\hyperlink{namespaceCatch_1_1Matchers_af4de9d3e501b83d17a048cf2107629dc}{Catch\+::\+Matchers\+::\+Matches}} (std\+::string const \&regex, \mbox{\hyperlink{namespaceCatch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_1_1Matchers_1_1Detail_a228a8fff5aa311bd0e3592b8cb711392}{Catch\+::\+Matchers\+::\+Detail\+::describe\+\_\+multi\+\_\+matcher}} (\mbox{\hyperlink{classCatch_1_1StringRef}{String\+Ref}} combine, std\+::string const \texorpdfstring{$\ast$}{*}descriptions\+\_\+begin, std\+::string const \texorpdfstring{$\ast$}{*}descriptions\+\_\+end)
\item 
void \mbox{\hyperlink{namespaceCatch_a4c77e898254807f1a2d7195ca324c19e}{Catch\+::handle\+Exception\+Match\+Expr}} (\mbox{\hyperlink{classCatch_1_1AssertionHandler}{Assertion\+Handler}} \&handler, String\+Matcher const \&matcher)
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_af65507889895c5c4b04fb831eeab2972}{Catch\+::get\+Formatted\+Duration}} (double duration)
\item 
bool \mbox{\hyperlink{namespaceCatch_af125966eee74f0256b8bfddec3840497}{Catch\+::should\+Show\+Duration}} (\mbox{\hyperlink{classCatch_1_1IConfig}{IConfig}} const \&config, double duration)
\item 
std\+::string \mbox{\hyperlink{namespaceCatch_ae5e405537e8a55293a1b6cad32e2cdb5}{Catch\+::serialize\+Filters}} (std\+::vector$<$ std\+::string $>$ const \&filters)
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceCatch_a78a94236ca5f49ef11f36cf02483cb1d}{Catch\+::operator$<$$<$}} (std\+::ostream \&out, line\+Of\+Chars value)
\item 
void \mbox{\hyperlink{namespaceCatch_a7fc9276bf852d1625d986c0cbc3eabce}{Catch\+::default\+List\+Reporters}} (std\+::ostream \&out, std\+::vector$<$ Reporter\+Description $>$ const \&descriptions, \mbox{\hyperlink{namespaceCatch_af85c0d46dfe687d923a157362fd07737}{Verbosity}} verbosity)
\item 
void \mbox{\hyperlink{namespaceCatch_a906d1c90c5a8118e737bd14bef2885ea}{Catch\+::default\+List\+Listeners}} (std\+::ostream \&out, std\+::vector$<$ Listener\+Description $>$ const \&descriptions)
\item 
void \mbox{\hyperlink{namespaceCatch_a29d53521f0da176f732c3a022dbb04df}{Catch\+::default\+List\+Tags}} (std\+::ostream \&out, std\+::vector$<$ Tag\+Info $>$ const \&tags, bool is\+Filtered)
\item 
void \mbox{\hyperlink{namespaceCatch_a6dce9f6d9a416fe7a06e6394d557606a}{Catch\+::default\+List\+Tests}} (std\+::ostream \&out, Colour\+Impl \texorpdfstring{$\ast$}{*}stream\+Colour, std\+::vector$<$ \mbox{\hyperlink{classCatch_1_1TestCaseHandle}{Test\+Case\+Handle}} $>$ const \&tests, bool is\+Filtered, \mbox{\hyperlink{namespaceCatch_af85c0d46dfe687d923a157362fd07737}{Verbosity}} verbosity)
\item 
void \mbox{\hyperlink{namespaceCatch_aecf85e8927841af21b8fcd3bab31df2b}{Catch\+::print\+Test\+Run\+Totals}} (std\+::ostream \&stream, Colour\+Impl \&stream\+Colour, \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} const \&totals)
\item 
void \mbox{\hyperlink{namespaceCatch_1_1Detail_af8703a4eaf12133aa02a50dee831f2bc}{Catch\+::\+Detail\+::register\+Reporter\+Impl}} (std\+::string const \&name, \mbox{\hyperlink{namespaceCatch_a7b0c740ea1bcc8618dc95cd8d36f9fd3}{IReporter\+Factory\+Ptr}} reporter\+Ptr)
\item 
void \mbox{\hyperlink{namespaceCatch_1_1Detail_aae9b0608769b42ff7bbd07687348c7e5}{Catch\+::\+Detail\+::register\+Listener\+Impl}} (\mbox{\hyperlink{classCatch_1_1Detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ Event\+Listener\+Factory $>$ listener\+Factory)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}} = -\/log( ( 1.\+0 -\/ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) \texorpdfstring{$\ast$}{*} ( 1.\+0 + \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) )
\item 
double \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}} = -\/2.\+7109920616438573243e-\/11
\item 
\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}
\item 
return \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}
\item 
int \mbox{\hyperlink{namespaceCatch_a58f10015e39cdee2bbb24ac91e274ba0}{Catch\+::\+String\+Maker$<$ float $>$\+::precision}} = std\+::numeric\+\_\+limits$<$float$>$\+::max\+\_\+digits10
\item 
int \mbox{\hyperlink{namespaceCatch_a0f791e073f1b954a32b5ca0cde9ab8b3}{Catch\+::\+String\+Maker$<$ double $>$\+::precision}} = std\+::numeric\+\_\+limits$<$double$>$\+::max\+\_\+digits10
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This file provides platform specific implementations of Fatal\+Condition\+Handler

This means that there is a lot of conditional compilation, and platform specific code. Currently, Catch2 supports a dummy handler (if no handler is desired), and 2 platform specific handlers\+:
\begin{DoxyItemize}
\item Windows\textquotesingle{} SEH
\item POSIX signals
\end{DoxyItemize}

Consequently, various pieces of code below are compiled if either of the platform specific handlers is enabled, or if none of them are enabled. It is assumed that both cannot be enabled at the same time, and doing so should cause a compilation error.

If another platform specific handler is added, the compile guards below will need to be updated taking these assumptions into account. 

\label{doc-define-members}
\Hypertarget{catch__amalgamated_8cpp_doc-define-members}
\doxysubsection{Macro Definition Documentation}
\Hypertarget{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!Digits@{Digits}}
\index{Digits@{Digits}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{Digits}{Digits}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12} 
\#define Digits(\begin{DoxyParamCaption}\item[{}]{\mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}}{}\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{(\ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}\ \&\ 0xFF'FF'FF'FF\ )\ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ lhs\_low\ =\ \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}(\ lhs\ );\ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ rhs\_low\ =\ \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}(\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ low\_low\ =\ (\ lhs\_low\ *\ rhs\_low\ );\ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ high\_high\ =\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ lhs\ )\ *\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ high\_low\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ lhs\ )\ *\ rhs\_low\ )\ +\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ low\_low\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ low\_high\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ lhs\_low\ *\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ rhs\ )\ )\ +\ \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}(\ high\_low\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\ high\_high\ +\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ high\_low\ )\ +\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}(\ low\_high\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ low\_high\ <<\ 32\ )\ |\ \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}(\ low\_low\ )\ \};\#undef\ \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{CarryBits}}\#undef\ \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{inline}\ ExtendedMultResult<std::uint64\_t>\ \ \ \ \ \ \ \ extendedMult(\ std::uint64\_t\ lhs,\ std::uint64\_t\ rhs\ )\ \{\#\textcolor{keywordflow}{if}\ defined(\ CATCH\_CONFIG\_UINT128\ )\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ result\ =\ \_\_uint128\_t(\ lhs\ )\ *\ \_\_uint128\_t(\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\ \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(\ result\ >>\ 64\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(\ result\ )\ \};\#elif\ defined(\ CATCH\_CONFIG\_MSVC\_UMUL128\ )\ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ high;\ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ low\ =\ \_umul128(\ lhs,\ rhs,\ \&high\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\ high,\ low\ \};\#\textcolor{keywordflow}{else}\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ extendedMultPortable(\ lhs,\ rhs\ );\#endif\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ UInt>\ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ ExtendedMultResult<UInt>\ extendedMult(\ UInt\ lhs,\ UInt\ rhs\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ std::is\_unsigned<UInt>::value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}extendedMult\ can\ only\ handle\ unsigned\ integers"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ \textcolor{keyword}{sizeof}(\ UInt\ )\ <\ \textcolor{keyword}{sizeof}(\ std::uint64\_t\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Generic\ extendedMult\ can\ only\ handle\ types\ smaller\ "{}}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}than\ uint64\_t"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }WideType\ =\ DoubleWidthUnsignedType\_t<UInt>;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ result\ =\ WideType(\ lhs\ )\ *\ WideType(\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}UInt\textcolor{keyword}{>}(\ result\ >>\ (\ CHAR\_BIT\ *\ \textcolor{keyword}{sizeof}(\ UInt\ )\ )\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}UInt\textcolor{keyword}{>}(\ result\ \&\ UInt(\ -\/1\ )\ )\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TargetType,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ Generator>\ \ \ \ \ \ \ \ \ \ \ \ std::enable\_if\_t<\textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ Generator::result\_type)\ >=\ \textcolor{keyword}{sizeof}(TargetType),\ \ \ \ \ \ \ \ \ \ \ \ TargetType>\ fillBitsFrom(Generator\&\ gen)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }gresult\_type\ =\ \textcolor{keyword}{typename}\ Generator::result\_type;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ std::is\_unsigned<TargetType>::value,\ \textcolor{stringliteral}{"{}Only\ unsigned\ integers\ are\ supported"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ Generator::min()\ ==\ 0\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Generator::max()\ ==\ \textcolor{keyword}{static\_cast<}gresult\_type\textcolor{keyword}{>}(\ -\/1\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Generator\ must\ be\ able\ to\ output\ all\ numbers\ in\ its\ result\ type\ (effectively\ it\ must\ be\ a\ random\ bit\ generator)"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ generated\_bits\ =\ \textcolor{keyword}{sizeof}(\ gresult\_type\ )\ *\ CHAR\_BIT;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ return\_bits\ =\ \textcolor{keyword}{sizeof}(\ TargetType\ )\ *\ CHAR\_BIT;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}TargetType\textcolor{keyword}{>}(\ gen()\ >>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ generated\_bits\ -\/\ return\_bits)\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TargetType,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ Generator>\ \ \ \ \ \ \ \ \ \ \ \ std::enable\_if\_t<\textcolor{keyword}{sizeof}(\textcolor{keyword}{typename}\ Generator::result\_type)\ <\ \textcolor{keyword}{sizeof}(TargetType),\ \ \ \ \ \ \ \ \ \ \ \ TargetType>\ fillBitsFrom(Generator\&\ gen)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }gresult\_type\ =\ \textcolor{keyword}{typename}\ Generator::result\_type;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ std::is\_unsigned<TargetType>::value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Only\ unsigned\ integers\ are\ supported"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ Generator::min()\ ==\ 0\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Generator::max()\ ==\ \textcolor{keyword}{static\_cast<}gresult\_type\textcolor{keyword}{>}(\ -\/1\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Generator\ must\ be\ able\ to\ output\ all\ numbers\ in\ its\ result\ type\ (effectively\ it\ must\ be\ a\ random\ bit\ generator)"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ generated\_bits\ =\ \textcolor{keyword}{sizeof}(\ gresult\_type\ )\ *\ CHAR\_BIT;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ return\_bits\ =\ \textcolor{keyword}{sizeof}(\ TargetType\ )\ *\ CHAR\_BIT;\ \ \ \ \ \ \ \ \ \ \ \ std::size\_t\ filled\_bits\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ TargetType\ ret\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{do}\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ret\ <<=\ generated\_bits;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ret\ |=\ gen();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ filled\_bits\ +=\ generated\_bits;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (\ filled\_bits\ <\ return\_bits\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ret;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OriginalType,\ \textcolor{keyword}{typename}\ Un\textcolor{keywordtype}{signed}Type>\ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \ \ \ \ \ \ \ std::enable\_if\_t<std::is\_signed<OriginalType>::value,\ UnsignedType>\ \ \ \ \ \ \ \ transposeToNaturalOrder(\ UnsignedType\ in\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{sizeof}(\ OriginalType\ )\ ==\ \textcolor{keyword}{sizeof}(\ UnsignedType\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}reordering\ requires\ the\ same\ sized\ types\ on\ both\ sides"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ std::is\_unsigned<UnsignedType>::value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Input\ type\ must\ be\ unsigned"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ highest\_bit\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ UnsignedType(\ 1\ )\ <<\ (\ \textcolor{keyword}{sizeof}(\ UnsignedType\ )\ *\ CHAR\_BIT\ -\/\ 1\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}UnsignedType\textcolor{keyword}{>}(\ in\ \string^\ highest\_bit\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ OriginalType,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ Un\textcolor{keywordtype}{signed}Type>\ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \ \ \ \ \ \ \ std::enable\_if\_t<std::is\_unsigned<OriginalType>::value,\ UnsignedType>\ \ \ \ \ \ \ \ \ \ \ \ transposeToNaturalOrder(UnsignedType\ in)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{sizeof}(\ OriginalType\ )\ ==\ \textcolor{keyword}{sizeof}(\ UnsignedType\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}reordering\ requires\ the\ same\ sized\ types\ on\ both\ sides"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ std::is\_unsigned<UnsignedType>::value,\ \textcolor{stringliteral}{"{}Input\ type\ must\ be\ unsigned"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ in;\ \ \ \ \ \ \ \ \}\ \ \ \ \}\ \}\ \#endif\ \textcolor{keyword}{namespace\ }Catch\ \{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ IntegerType>\textcolor{keyword}{class\ }uniform\_integer\_distribution\ \{\ \ \ \ \textcolor{keyword}{static\_assert}(std::is\_integral<IntegerType>::value,\ \textcolor{stringliteral}{"{}..."{}});\ \ \ \ \textcolor{keyword}{using\ }UnsignedIntegerType\ =\ Detail::SizedUnsignedType\_t<\textcolor{keyword}{sizeof}(IntegerType)>;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ UnsignedIntegerType\ m\_a;\ \ \ \ \ \ \ \ UnsignedIntegerType\ m\_ab\_distance;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ UnsignedIntegerType\ m\_rejection\_threshold\ =\ 0;\ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ UnsignedIntegerType\ computeDistance(IntegerType\ a,\ IntegerType\ b)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ transposeTo(b)\ -\/\ transposeTo(a)\ +\ 1;\ \ \ \ \}\ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ UnsignedIntegerType\ computeRejectionThreshold(UnsignedIntegerType\ ab\_distance)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\ ab\_distance\ ==\ 0\ )\ \{\ \textcolor{keywordflow}{return}\ 0;\ \}\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (\ \string~ab\_distance\ +\ 1\ )\ \%\ ab\_distance;\ \ \ \ \}\ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ UnsignedIntegerType\ transposeTo(IntegerType\ in)\ \{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ Detail::transposeToNaturalOrder<IntegerType>(\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}UnsignedIntegerType\textcolor{keyword}{>}(\ in\ )\ );\ \ \ \ \}\ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ IntegerType\ transposeBack(UnsignedIntegerType\ in)\ \{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}IntegerType\textcolor{keyword}{>}(\ \ \ \ \ \ \ \ \ \ \ \ Detail::transposeToNaturalOrder<IntegerType>(in)\ );\ \ \ \ \}\textcolor{keyword}{public}:\ \ \ \ \textcolor{keyword}{using\ }result\_type\ =\ IntegerType;\ \ \ \ \textcolor{keyword}{constexpr}\ uniform\_integer\_distribution(\ IntegerType\ a,\ IntegerType\ b\ ):\ \ \ \ \ \ \ \ m\_a(\ transposeTo(a)\ ),\ \ \ \ \ \ \ \ m\_ab\_distance(\ computeDistance(a,\ b)\ ),\ \ \ \ \ \ \ \ m\_rejection\_threshold(\ computeRejectionThreshold(m\_ab\_distance)\ )\ \{\ \ \ \ \ \ \ \ assert(\ a\ <=\ b\ );\ \ \ \ \}\ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Generator>\ \ \ \ \textcolor{keyword}{constexpr}\ result\_type\ operator()(\ Generator\&\ g\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\ m\_ab\_distance\ ==\ 0\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ transposeBack(\ Detail::fillBitsFrom<UnsignedIntegerType>(\ g\ )\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ random\_number\ =\ Detail::fillBitsFrom<UnsignedIntegerType>(\ g\ );\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ emul\ =\ Detail::extendedMult(\ random\_number,\ m\_ab\_distance\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (emul.lower\ <\ m\_rejection\_threshold)\ \{\ \ \ \ \ \ \ \ \ \ \ \ random\_number\ =\ Detail::fillBitsFrom<UnsignedIntegerType>(\ g\ );\ \ \ \ \ \ \ \ \ \ \ \ emul\ =\ Detail::extendedMult(\ random\_number,\ m\_ab\_distance\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ transposeBack(m\_a\ +\ emul.upper);\ \ \ \ \}\ \ \ \ \textcolor{keyword}{constexpr}\ result\_type\ a()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ transposeBack(m\_a);\ \}\ \ \ \ \textcolor{keyword}{constexpr}\ result\_type\ b()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ transposeBack(m\_ab\_distance\ +\ m\_a\ -\/\ 1);\ \}\};\}\ \#endif\ \#ifndef\ CATCH\_UNIFORM\_FLOATING\_POINT\_DISTRIBUTION\_HPP\_INCLUDED\#define\ CATCH\_UNIFORM\_FLOATING\_POINT\_DISTRIBUTION\_HPP\_INCLUDED\#ifndef\ CATCH\_RANDOM\_FLOATING\_POINT\_HELPERS\_HPP\_INCLUDED\#define\ CATCH\_RANDOM\_FLOATING\_POINT\_HELPERS\_HPP\_INCLUDED\#ifndef\ CATCH\_POLYFILLS\_HPP\_INCLUDED\#define\ CATCH\_POLYFILLS\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{namespaceCatch_aff37796f0f578c2816f74267e641c5f7}{isnan}}(\textcolor{keywordtype}{float}\ f);\ \ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{namespaceCatch_aff37796f0f578c2816f74267e641c5f7}{isnan}}(\textcolor{keywordtype}{double}\ d);\ \ \ \ \textcolor{keywordtype}{float}\ \mbox{\hyperlink{namespaceCatch_ae65d074e6c60320640a500d302b83bb2}{nextafter}}(\textcolor{keywordtype}{float}\ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}},\ \textcolor{keywordtype}{float}\ y);\ \ \ \ \textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceCatch_ae65d074e6c60320640a500d302b83bb2}{nextafter}}(\textcolor{keywordtype}{double}\ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}},\ \textcolor{keywordtype}{double}\ y);\}\#endif\ \#include\ <cassert>\#include\ <cmath>\#include\ <cstdint>\#include\ <limits>\#include\ <type\_traits>\textcolor{keyword}{namespace\ }Catch\ \{\ \ \ \ \textcolor{keyword}{namespace\ }Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>\ \ \ \ \ \ \ \ FloatType\ gamma(FloatType\ a,\ FloatType\ b)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(\ std::is\_floating\_point<FloatType>::value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}gamma\ returns\ the\ largest\ ULP\ magnitude\ within\ "{}}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}floating\ point\ range\ [a,\ b].\ This\ only\ makes\ sense\ "{}}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}for\ floating\ point\ types"{}}\ );\ \ \ \ \ \ \ \ \ \ \ \ assert(\ a\ <=\ b\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ gamma\_up\ =\ \mbox{\hyperlink{namespaceCatch_ae65d074e6c60320640a500d302b83bb2}{Catch::nextafter}}(\ a,\ std::numeric\_limits<FloatType>::infinity()\ )\ -\/\ a;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ gamma\_down\ =\ b\ -\/\ \mbox{\hyperlink{namespaceCatch_ae65d074e6c60320640a500d302b83bb2}{Catch::nextafter}}(\ b,\ -\/std::numeric\_limits<FloatType>::infinity()\ );\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ gamma\_up\ <\ gamma\_down\ ?\ gamma\_down\ :\ gamma\_up;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ FloatingPoint>\ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }DistanceTypePicker;\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <>\ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }DistanceTypePicker<float>\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }type\ =\ std::uint32\_t;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <>\ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }DistanceTypePicker<double>\ \{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }type\ =\ std::uint64\_t;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }DistanceType\ =\ \textcolor{keyword}{typename}\ DistanceTypePicker<T>::type;\#\textcolor{keywordflow}{if}\ defined(\ \_\_GNUC\_\_\ )\ ||\ defined(\ \_\_clang\_\_\ )\textcolor{preprocessor}{\#\ \ \ \ pragma\ GCC\ diagnostic\ push\#\ \ \ \ pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wfloat-\/equal"{}\#endif\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ FloatType>\ \ \ \ \ \ \ \ DistanceType<FloatType>\ \ \ \ \ \ \ \ count\_equidistant\_floats(\ FloatType\ a,\ FloatType\ b,\ FloatType\ distance\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ assert(\ a\ <=\ b\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ ag\ =\ a\ /\ distance;\ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ bg\ =\ b\ /\ distance;\ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ s\ =\ bg\ -\/\ ag;\ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ err\ =\ (\ std::fabs(\ a\ )\ <=\ std::fabs(\ b\ )\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ -\/ag\ -\/\ (\ s\ -\/\ bg\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ bg\ -\/\ (\ s\ +\ ag\ );\ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ ceil\_s\ =\ static\_cast<DistanceType<FloatType>>(\ std::ceil(\ s\ )\ );\ \ \ \ \ \ \ \ \ \ \ \ return\ (\ ceil\_s\ !=\ s\ )\ ?\ ceil\_s\ :\ ceil\_s\ +\ (\ err\ >\ 0\ );\ \ \ \ \ \ \ \ \}\#if\ defined(\ \_\_GNUC\_\_\ )\ ||\ defined(\ \_\_clang\_\_\ )\#\ \ \ \ pragma\ GCC\ diagnostic\ pop\#endif\ \ \ \ \}\}\ \#endif\ \#include\ <cmath>\#include\ <type\_traits>namespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\#if\ defined(\ \_\_GNUC\_\_\ )\ ||\ defined(\ \_\_clang\_\_\ )\#\ \ \ \ pragma\ GCC\ diagnostic\ push\#\ \ \ \ pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wfloat-\/equal"{}\#endif\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constexpr\ std::uint64\_t\ calculate\_max\_steps\_in\_one\_go(double\ gamma)\ \{\ \ \ \ \ \ \ \ \ \ \ \ if\ (\ gamma\ ==\ 1.99584030953472e+292\ )\ \{\ return\ 9007199254740991;\ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ static\_cast<std::uint64\_t>(\ -\/1\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ constexpr\ std::uint32\_t\ calculate\_max\_steps\_in\_one\_go(float\ gamma)\ \{\ \ \ \ \ \ \ \ \ \ \ \ if\ (\ gamma\ ==\ 2.028241e+31f\ )\ \{\ return\ 16777215;\ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ static\_cast<std::uint32\_t>(\ -\/1\ );\ \ \ \ \ \ \ \ \}\#if\ defined(\ \_\_GNUC\_\_\ )\ ||\ defined(\ \_\_clang\_\_\ )\#\ \ \ \ pragma\ GCC\ diagnostic\ pop\#endif\ \ \ \ \}template\ <typename\ FloatType>class\ uniform\_floating\_point\_distribution\ \{\ \ \ \ static\_assert(std::is\_floating\_point<FloatType>::value,\ "{}..."{});\ \ \ \ static\_assert(!std::is\_same<FloatType,\ long\ double>::value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}We\ do\ not\ support\ long\ double\ due\ to\ inconsistent\ behaviour\ between\ platforms"{});\ \ \ \ using\ WidthType\ =\ Detail::DistanceType<FloatType>;\ \ \ \ FloatType\ m\_a,\ m\_b;\ \ \ \ FloatType\ m\_ulp\_magnitude;\ \ \ \ WidthType\ m\_floats\_in\_range;\ \ \ \ uniform\_integer\_distribution<WidthType>\ m\_int\_dist;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ WidthType\ m\_max\_steps\_in\_one\_go;\ \ \ \ \ \ \ \ bool\ m\_a\_has\_leq\_magnitude;public:\ \ \ \ using\ result\_type\ =\ FloatType;\ \ \ \ uniform\_floating\_point\_distribution(\ FloatType\ a,\ FloatType\ b\ ):\ \ \ \ \ \ \ \ m\_a(\ a\ ),\ \ \ \ \ \ \ \ m\_b(\ b\ ),\ \ \ \ \ \ \ \ m\_ulp\_magnitude(\ Detail::gamma(\ m\_a,\ m\_b\ )\ ),\ \ \ \ \ \ \ \ m\_floats\_in\_range(\ Detail::count\_equidistant\_floats(\ m\_a,\ m\_b,\ m\_ulp\_magnitude\ )\ ),\ \ \ \ \ \ \ \ m\_int\_dist(0,\ m\_floats\_in\_range),\ \ \ \ \ \ \ \ m\_max\_steps\_in\_one\_go(\ Detail::calculate\_max\_steps\_in\_one\_go(m\_ulp\_magnitude)),\ \ \ \ \ \ \ \ m\_a\_has\_leq\_magnitude(std::fabs(m\_a)\ <=\ std::fabs(m\_b))\ \ \ \ \{\ \ \ \ \ \ \ \ assert(\ a\ <=\ b\ );\ \ \ \ \}\ \ \ \ template\ <typename\ Generator>\ \ \ \ result\_type\ operator()(\ Generator\&\ g\ )\ \{\ \ \ \ \ \ \ \ WidthType\ steps\ =\ m\_int\_dist(\ g\ );\ \ \ \ \ \ \ \ if\ (\ m\_a\_has\_leq\_magnitude\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ if\ (\ steps\ ==\ m\_floats\_in\_range\ )\ \{\ return\ m\_a;\ \}\ \ \ \ \ \ \ \ \ \ \ \ auto\ b\ =\ m\_b;\ \ \ \ \ \ \ \ \ \ \ \ while\ (steps\ >\ m\_max\_steps\_in\_one\_go)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ b\ -\/=\ m\_max\_steps\_in\_one\_go\ *\ m\_ulp\_magnitude;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ steps\ -\/=\ m\_max\_steps\_in\_one\_go;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ b\ -\/\ steps\ *\ m\_ulp\_magnitude;\ \ \ \ \ \ \ \ \}\ else\ \{\ \ \ \ \ \ \ \ \ \ \ \ if\ (\ steps\ ==\ m\_floats\_in\_range\ )\ \{\ return\ m\_b;\ \}\ \ \ \ \ \ \ \ \ \ \ \ auto\ a\ =\ m\_a;\ \ \ \ \ \ \ \ \ \ \ \ while\ (steps\ >\ m\_max\_steps\_in\_one\_go)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a\ +=\ m\_max\_steps\_in\_one\_go\ *\ m\_ulp\_magnitude;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ steps\ -\/=\ m\_max\_steps\_in\_one\_go;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ a\ +\ steps\ *\ m\_ulp\_magnitude;\ \ \ \ \ \ \ \ \}\ \ \ \ \}\ \ \ \ result\_type\ a()\ const\ \{\ return\ m\_a;\ \}\ \ \ \ result\_type\ b()\ const\ \{\ return\ m\_b;\ \}\};\}\ \#endif\ namespace\ Catch\ \{namespace\ Generators\ \{namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::uint32\_t\ getSeed();\}template\ <typename\ Float>class\ RandomFloatingGenerator\ final\ :\ public\ IGenerator<Float>\ \{\ \ \ \ Catch::SimplePcg32\ m\_rng;\ \ \ \ Catch::uniform\_floating\_point\_distribution<Float>\ m\_dist;\ \ \ \ Float\ m\_current\_number;public:\ \ \ \ RandomFloatingGenerator(\ Float\ a,\ Float\ b,\ std::uint32\_t\ seed\ ):\ \ \ \ \ \ \ \ m\_rng(seed),\ \ \ \ \ \ \ \ m\_dist(a,\ b)\ \{\ \ \ \ \ \ \ \ static\_cast<void>(next());\ \ \ \ \}\ \ \ \ Float\ const\&\ get()\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_current\_number;\ \ \ \ \}\ \ \ \ bool\ next()\ override\ \{\ \ \ \ \ \ \ \ m\_current\_number\ =\ m\_dist(m\_rng);\ \ \ \ \ \ \ \ return\ true;\ \ \ \ \}\};template\ <>class\ RandomFloatingGenerator<long\ double>\ final\ :\ public\ IGenerator<long\ double>\ \{\ \ \ \ \ \ \ \ \ \ \ \ struct\ PImpl;\ \ \ \ Catch::Detail::unique\_ptr<PImpl>\ m\_pimpl;\ \ \ \ long\ double\ m\_current\_number;public:\ \ \ \ RandomFloatingGenerator(\ long\ double\ a,\ long\ double\ b,\ std::uint32\_t\ seed\ );\ \ \ \ long\ double\ const\&\ get()\ const\ override\ \{\ return\ m\_current\_number;\ \}\ \ \ \ bool\ next()\ override;\ \ \ \ \string~RandomFloatingGenerator()\ override;\ \};template\ <typename\ Integer>class\ RandomIntegerGenerator\ final\ :\ public\ IGenerator<Integer>\ \{\ \ \ \ Catch::SimplePcg32\ m\_rng;\ \ \ \ Catch::uniform\_integer\_distribution<Integer>\ m\_dist;\ \ \ \ Integer\ m\_current\_number;public:\ \ \ \ RandomIntegerGenerator(\ Integer\ a,\ Integer\ b,\ std::uint32\_t\ seed\ ):\ \ \ \ \ \ \ \ m\_rng(seed),\ \ \ \ \ \ \ \ m\_dist(a,\ b)\ \{\ \ \ \ \ \ \ \ static\_cast<void>(next());\ \ \ \ \}\ \ \ \ Integer\ const\&\ get()\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_current\_number;\ \ \ \ \}\ \ \ \ bool\ next()\ override\ \{\ \ \ \ \ \ \ \ m\_current\_number\ =\ m\_dist(m\_rng);\ \ \ \ \ \ \ \ return\ true;\ \ \ \ \}\};template\ <typename\ T>std::enable\_if\_t<std::is\_integral<T>::value,\ GeneratorWrapper<T>>random(T\ a,\ T\ b)\ \{\ \ \ \ return\ GeneratorWrapper<T>(\ \ \ \ \ \ \ \ Catch::Detail::make\_unique<RandomIntegerGenerator<T>>(a,\ b,\ Detail::getSeed())\ \ \ \ );\}template\ <typename\ T>std::enable\_if\_t<std::is\_floating\_point<T>::value,GeneratorWrapper<T>>random(T\ a,\ T\ b)\ \{\ \ \ \ return\ GeneratorWrapper<T>(\ \ \ \ \ \ \ \ Catch::Detail::make\_unique<RandomFloatingGenerator<T>>(a,\ b,\ Detail::getSeed())\ \ \ \ );\}\}\ \}\ \#endif\ \#ifndef\ CATCH\_GENERATORS\_RANGE\_HPP\_INCLUDED\#define\ CATCH\_GENERATORS\_RANGE\_HPP\_INCLUDED\#include\ <iterator>\#include\ <type\_traits>namespace\ Catch\ \{namespace\ Generators\ \{template\ <typename\ T>class\ RangeGenerator\ final\ :\ public\ IGenerator<T>\ \{\ \ \ \ T\ m\_current;\ \ \ \ T\ m\_end;\ \ \ \ T\ m\_step;\ \ \ \ bool\ m\_positive;public:\ \ \ \ RangeGenerator(T\ const\&\ start,\ T\ const\&\ end,\ T\ const\&\ step):\ \ \ \ \ \ \ \ m\_current(start),\ \ \ \ \ \ \ \ m\_end(end),\ \ \ \ \ \ \ \ m\_step(step),\ \ \ \ \ \ \ \ m\_positive(m\_step\ >\ T(0))\ \ \ \ \{\ \ \ \ \ \ \ \ assert(m\_current\ !=\ m\_end\ \&\&\ "{}Range\ start\ and\ end\ cannot\ be\ equal"{});\ \ \ \ \ \ \ \ assert(m\_step\ !=\ T(0)\ \&\&\ "{}Step\ size\ cannot\ be\ zero"{});\ \ \ \ \ \ \ \ assert(((m\_positive\ \&\&\ m\_current\ <=\ m\_end)\ ||\ (!m\_positive\ \&\&\ m\_current\ >=\ m\_end))\ \&\&\ "{}Step\ moves\ away\ from\ end"{});\ \ \ \ \}\ \ \ \ RangeGenerator(T\ const\&\ start,\ T\ const\&\ end):\ \ \ \ \ \ \ \ RangeGenerator(start,\ end,\ (start\ <\ end)\ ?\ T(1)\ :\ T(-\/1))\ \ \ \ \{\}\ \ \ \ T\ const\&\ get()\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_current;\ \ \ \ \}\ \ \ \ bool\ next()\ override\ \{\ \ \ \ \ \ \ \ m\_current\ +=\ m\_step;\ \ \ \ \ \ \ \ return\ (m\_positive)\ ?\ (m\_current\ <\ m\_end)\ :\ (m\_current\ >\ m\_end);\ \ \ \ \}\};template\ <typename\ T>GeneratorWrapper<T>\ range(T\ const\&\ start,\ T\ const\&\ end,\ T\ const\&\ step)\ \{\ \ \ \ static\_assert(std::is\_arithmetic<T>::value\ \&\&\ !std::is\_same<T,\ bool>::value,\ "{}Type\ must\ be\ numeric"{});\ \ \ \ return\ GeneratorWrapper<T>(Catch::Detail::make\_unique<RangeGenerator<T>>(start,\ end,\ step));\}template\ <typename\ T>GeneratorWrapper<T>\ range(T\ const\&\ start,\ T\ const\&\ end)\ \{\ \ \ \ static\_assert(std::is\_integral<T>::value\ \&\&\ !std::is\_same<T,\ bool>::value,\ "{}Type\ must\ be\ an\ integer"{});\ \ \ \ return\ GeneratorWrapper<T>(Catch::Detail::make\_unique<RangeGenerator<T>>(start,\ end));\}template\ <typename\ T>class\ IteratorGenerator\ final\ :\ public\ IGenerator<T>\ \{\ \ \ \ static\_assert(!std::is\_same<T,\ bool>::value,\ \ \ \ \ \ \ \ "{}IteratorGenerator\ currently\ does\ not\ support\ bools"{}\ \ \ \ \ \ \ \ "{}because\ of\ std::vector<bool>\ specialization"{});\ \ \ \ std::vector<T>\ m\_elems;\ \ \ \ size\_t\ m\_current\ =\ 0;public:\ \ \ \ template\ <typename\ InputIterator,\ typename\ InputSentinel>\ \ \ \ IteratorGenerator(InputIterator\ first,\ InputSentinel\ last):m\_elems(first,\ last)\ \{\ \ \ \ \ \ \ \ if\ (m\_elems.empty())\ \{\ \ \ \ \ \ \ \ \ \ \ \ Detail::throw\_generator\_exception("{}IteratorGenerator\ received\ no\ valid\ values"{});\ \ \ \ \ \ \ \ \}\ \ \ \ \}\ \ \ \ T\ const\&\ get()\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_elems[m\_current];\ \ \ \ \}\ \ \ \ bool\ next()\ override\ \{\ \ \ \ \ \ \ \ ++m\_current;\ \ \ \ \ \ \ \ return\ m\_current\ !=\ m\_elems.size();\ \ \ \ \}\};template\ <typename\ InputIterator,\ \ \ \ \ \ \ \ \ \ typename\ InputSentinel,\ \ \ \ \ \ \ \ \ \ typename\ ResultType\ =\ std::remove\_const\_t<typename\ std::iterator\_traits<InputIterator>::value\_type>>GeneratorWrapper<ResultType>\ from\_range(InputIterator\ from,\ InputSentinel\ to)\ \{\ \ \ \ return\ GeneratorWrapper<ResultType>(Catch::Detail::make\_unique<IteratorGenerator<ResultType>>(from,\ to));\}template\ <typename\ Container>auto\ from\_range(Container\ const\&\ cnt)\ \{\ \ \ \ using\ std::begin;\ \ \ \ using\ std::end;\ \ \ \ return\ from\_range(\ begin(\ cnt\ ),\ end(\ cnt\ )\ );\}\}\ \}\ \#endif\ \#endif\ \#ifndef\ CATCH\_INTERFACES\_ALL\_HPP\_INCLUDED\#define\ CATCH\_INTERFACES\_ALL\_HPP\_INCLUDED\#ifndef\ CATCH\_INTERFACES\_REPORTER\_HPP\_INCLUDED\#define\ CATCH\_INTERFACES\_REPORTER\_HPP\_INCLUDED\#ifndef\ CATCH\_TEST\_RUN\_INFO\_HPP\_INCLUDED\#define\ CATCH\_TEST\_RUN\_INFO\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ struct\ TestRunInfo\ \{\ \ \ \ \ \ \ \ constexpr\ TestRunInfo(StringRef\ \_name)\ :\ name(\_name)\ \{\}\ \ \ \ \ \ \ \ StringRef\ name;\ \ \ \ \};\}\ \#endif\ \#include\ <map>\#include\ <string>\#include\ <vector>\#include\ <iosfwd>namespace\ Catch\ \{\ \ \ \ struct\ ReporterDescription;\ \ \ \ struct\ ListenerDescription;\ \ \ \ struct\ TagInfo;\ \ \ \ struct\ TestCaseInfo;\ \ \ \ class\ TestCaseHandle;\ \ \ \ class\ IConfig;\ \ \ \ class\ IStream;\ \ \ \ enum\ class\ ColourMode\ :\ std::uint8\_t;\ \ \ \ struct\ ReporterConfig\ \{\ \ \ \ \ \ \ \ ReporterConfig(\ IConfig\ const*\ \_fullConfig,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::unique\_ptr<IStream>\ \_stream,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourMode\ colourMode,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::map<std::string,\ std::string>\ customOptions\ );\ \ \ \ \ \ \ \ ReporterConfig(\ ReporterConfig\&\&\ )\ =\ default;\ \ \ \ \ \ \ \ ReporterConfig\&\ operator=(\ ReporterConfig\&\&\ )\ =\ default;\ \ \ \ \ \ \ \ \string~ReporterConfig();\ \ \ \ \ \ \ \ \ Detail::unique\_ptr<IStream>\ takeStream()\ \&\&;\ \ \ \ \ \ \ \ IConfig\ const*\ fullConfig()\ const;\ \ \ \ \ \ \ \ ColourMode\ colourMode()\ const;\ \ \ \ \ \ \ \ std::map<std::string,\ std::string>\ const\&\ customOptions()\ const;\ \ \ \ private:\ \ \ \ \ \ \ \ Detail::unique\_ptr<IStream>\ m\_stream;\ \ \ \ \ \ \ \ IConfig\ const*\ m\_fullConfig;\ \ \ \ \ \ \ \ ColourMode\ m\_colourMode;\ \ \ \ \ \ \ \ std::map<std::string,\ std::string>\ m\_customOptions;\ \ \ \ \};\ \ \ \ struct\ AssertionStats\ \{\ \ \ \ \ \ \ \ AssertionStats(\ AssertionResult\ const\&\ \_assertionResult,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<MessageInfo>\ const\&\ \_infoMessages,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Totals\ const\&\ \_totals\ );\ \ \ \ \ \ \ \ AssertionStats(\ AssertionStats\ const\&\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ default;\ \ \ \ \ \ \ \ AssertionStats(\ AssertionStats\ \&\&\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\ default;\ \ \ \ \ \ \ \ AssertionStats\&\ operator\ =\ (\ AssertionStats\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ AssertionStats\&\ operator\ =\ (\ AssertionStats\ \&\&\ )\ \ \ \ \ =\ delete;\ \ \ \ \ \ \ \ AssertionResult\ assertionResult;\ \ \ \ \ \ \ \ std::vector<MessageInfo>\ infoMessages;\ \ \ \ \ \ \ \ Totals\ totals;\ \ \ \ \};\ \ \ \ struct\ SectionStats\ \{\ \ \ \ \ \ \ \ SectionStats(\ \ \ SectionInfo\&\&\ \_sectionInfo,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Counts\ const\&\ \_assertions,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ \_durationInSeconds,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ \_missingAssertions\ );\ \ \ \ \ \ \ \ SectionInfo\ sectionInfo;\ \ \ \ \ \ \ \ Counts\ assertions;\ \ \ \ \ \ \ \ double\ durationInSeconds;\ \ \ \ \ \ \ \ bool\ missingAssertions;\ \ \ \ \};\ \ \ \ struct\ TestCaseStats\ \{\ \ \ \ \ \ \ \ TestCaseStats(\ \ TestCaseInfo\ const\&\ \_testInfo,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Totals\ const\&\ \_totals,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\&\&\ \_stdOut,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\&\&\ \_stdErr,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ \_aborting\ );\ \ \ \ \ \ \ \ TestCaseInfo\ const\ *\ testInfo;\ \ \ \ \ \ \ \ Totals\ totals;\ \ \ \ \ \ \ \ std::string\ stdOut;\ \ \ \ \ \ \ \ std::string\ stdErr;\ \ \ \ \ \ \ \ bool\ aborting;\ \ \ \ \};\ \ \ \ struct\ TestRunStats\ \{\ \ \ \ \ \ \ \ TestRunStats(\ \ \ TestRunInfo\ const\&\ \_runInfo,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Totals\ const\&\ \_totals,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ \_aborting\ );\ \ \ \ \ \ \ \ TestRunInfo\ runInfo;\ \ \ \ \ \ \ \ Totals\ totals;\ \ \ \ \ \ \ \ bool\ aborting;\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ struct\ ReporterPreferences\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ shouldRedirectStdOut\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ shouldReportAllAssertions\ =\ false;\ \ \ \ \};\ \ \ \ \ \ \ \ class\ IEventListener\ \{\ \ \ \ protected:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ReporterPreferences\ m\_preferences;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IConfig\ const*\ m\_config;\ \ \ \ public:\ \ \ \ \ \ \ \ IEventListener(\ IConfig\ const*\ config\ ):\ m\_config(\ config\ )\ \{\}\ \ \ \ \ \ \ \ virtual\ \string~IEventListener();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ReporterPreferences\ const\&\ getPreferences()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ m\_preferences;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ noMatchingTestCases(\ StringRef\ unmatchedSpec\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ reportInvalidTestSpec(\ StringRef\ invalidArgument\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testRunStarting(\ TestRunInfo\ const\&\ testRunInfo\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testCaseStarting(\ TestCaseInfo\ const\&\ testInfo\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testCasePartialStarting(\ TestCaseInfo\ const\&\ testInfo,\ uint64\_t\ partNumber\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ sectionStarting(\ SectionInfo\ const\&\ sectionInfo\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ benchmarkPreparing(\ StringRef\ benchmarkName\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ benchmarkInfo\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ benchmarkStats\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ benchmarkFailed(\ StringRef\ benchmarkName\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ assertionStarting(\ AssertionInfo\ const\&\ assertionInfo\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ assertionEnded(\ AssertionStats\ const\&\ assertionStats\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ sectionEnded(\ SectionStats\ const\&\ sectionStats\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testCasePartialEnded(TestCaseStats\ const\&\ testCaseStats,\ uint64\_t\ partNumber\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testCaseEnded(\ TestCaseStats\ const\&\ testCaseStats\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testRunEnded(\ TestRunStats\ const\&\ testRunStats\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ skipTest(\ TestCaseInfo\ const\&\ testInfo\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ fatalErrorEncountered(\ StringRef\ error\ )\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ listReporters(std::vector<ReporterDescription>\ const\&\ descriptions)\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ listListeners(std::vector<ListenerDescription>\ const\&\ descriptions)\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ listTests(std::vector<TestCaseHandle>\ const\&\ tests)\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ listTags(std::vector<TagInfo>\ const\&\ tags)\ =\ 0;\ \ \ \ \};\ \ \ \ using\ IEventListenerPtr\ =\ Detail::unique\_ptr<IEventListener>;\}\ \#endif\ \#ifndef\ CATCH\_INTERFACES\_REPORTER\_FACTORY\_HPP\_INCLUDED\#define\ CATCH\_INTERFACES\_REPORTER\_FACTORY\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\ \ \ \ struct\ ReporterConfig;\ \ \ \ class\ IConfig;\ \ \ \ class\ IEventListener;\ \ \ \ using\ IEventListenerPtr\ =\ Detail::unique\_ptr<IEventListener>;\ \ \ \ class\ IReporterFactory\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ virtual\ \string~IReporterFactory();\ \ \ \ \ \ \ \ \ virtual\ IEventListenerPtr\ \ \ \ \ \ \ \ create(\ ReporterConfig\&\&\ config\ )\ const\ =\ 0;\ \ \ \ \ \ \ \ virtual\ std::string\ getDescription()\ const\ =\ 0;\ \ \ \ \};\ \ \ \ using\ IReporterFactoryPtr\ =\ Detail::unique\_ptr<IReporterFactory>;\ \ \ \ class\ EventListenerFactory\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ virtual\ \string~EventListenerFactory();\ \ \ \ \ \ \ \ \ virtual\ IEventListenerPtr\ create(\ IConfig\ const*\ config\ )\ const\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ StringRef\ getName()\ const\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ std::string\ getDescription()\ const\ =\ 0;\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_INTERFACES\_TAG\_ALIAS\_REGISTRY\_HPP\_INCLUDED\#define\ CATCH\_INTERFACES\_TAG\_ALIAS\_REGISTRY\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\ \ \ \ struct\ TagAlias;\ \ \ \ class\ ITagAliasRegistry\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ virtual\ \string~ITagAliasRegistry();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ TagAlias\ const*\ find(\ std::string\ const\&\ alias\ )\ const\ =\ 0;\ \ \ \ \ \ \ \ virtual\ std::string\ expandAliases(\ std::string\ const\&\ unexpandedTestSpec\ )\ const\ =\ 0;\ \ \ \ \ \ \ \ static\ ITagAliasRegistry\ const\&\ get();\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_INTERFACES\_TESTCASE\_HPP\_INCLUDED\#define\ CATCH\_INTERFACES\_TESTCASE\_HPP\_INCLUDED\#include\ <vector>namespace\ Catch\ \{\ \ \ \ struct\ TestCaseInfo;\ \ \ \ class\ TestCaseHandle;\ \ \ \ class\ IConfig;\ \ \ \ class\ ITestCaseRegistry\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ virtual\ \string~ITestCaseRegistry();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ std::vector<TestCaseInfo*\ >\ const\&\ getAllInfos()\ const\ =\ 0;\ \ \ \ \ \ \ \ virtual\ std::vector<TestCaseHandle>\ const\&\ getAllTests()\ const\ =\ 0;\ \ \ \ \ \ \ \ virtual\ std::vector<TestCaseHandle>\ const\&\ getAllTestsSorted(\ IConfig\ const\&\ config\ )\ const\ =\ 0;\ \ \ \ \};\}\#endif\ \#endif\ \#ifndef\ CATCH\_CASE\_INSENSITIVE\_COMPARISONS\_HPP\_INCLUDED\#define\ CATCH\_CASE\_INSENSITIVE\_COMPARISONS\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ struct\ CaseInsensitiveLess\ \{\ \ \ \ \ \ \ \ \ \ \ \ bool\ operator()(\ StringRef\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StringRef\ rhs\ )\ const;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ struct\ CaseInsensitiveEqualTo\ \{\ \ \ \ \ \ \ \ \ \ \ \ bool\ operator()(\ StringRef\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StringRef\ rhs\ )\ const;\ \ \ \ \ \ \ \ \};\ \ \ \ \}\ \}\ \#endif\ \#ifndef\ CATCH\_CONFIG\_ANDROID\_LOGWRITE\_HPP\_INCLUDED\#define\ CATCH\_CONFIG\_ANDROID\_LOGWRITE\_HPP\_INCLUDED\#if\ defined(\_\_ANDROID\_\_)\#\ \ \ \ define\ CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE\#endif\#if\ defined(\ CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE\ )\ \&\&\ \(\backslash\)\ \ \ \ !defined(\ CATCH\_CONFIG\_NO\_ANDROID\_LOGWRITE\ )\ \&\&\ \ \ \ \ \ \(\backslash\)\ \ \ \ !defined(\ CATCH\_CONFIG\_ANDROID\_LOGWRITE\ )\#\ \ \ \ define\ CATCH\_CONFIG\_ANDROID\_LOGWRITE\#endif\#endif\ \#ifndef\ CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP\_INCLUDED\#define\ CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP\_INCLUDED\#if\ defined(\_MSC\_VER)\#\ \ if\ \_MSC\_VER\ >=\ 1900\ \#\ \ \ \ define\ CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS\#\ \ endif\#endif\#include\ <exception>\#if\ defined(\_\_cpp\_lib\_uncaught\_exceptions)\ \(\backslash\)\ \ \ \ \&\&\ !defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)\#\ \ define\ CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS\#endif\ \#if\ defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)\ \(\backslash\)\ \ \ \ \&\&\ !defined(CATCH\_CONFIG\_NO\_CPP17\_UNCAUGHT\_EXCEPTIONS)\ \(\backslash\)\ \ \ \ \&\&\ !defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)\#\ \ define\ CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS\#endif\#endif\ \#ifndef\ CATCH\_CONSOLE\_COLOUR\_HPP\_INCLUDED\#define\ CATCH\_CONSOLE\_COLOUR\_HPP\_INCLUDED\#include\ <iosfwd>\#include\ <cstdint>namespace\ Catch\ \{\ \ \ \ enum\ class\ ColourMode\ :\ std::uint8\_t;\ \ \ \ class\ IStream;\ \ \ \ struct\ Colour\ \{\ \ \ \ \ \ \ \ enum\ Code\ \{\ \ \ \ \ \ \ \ \ \ \ \ None\ =\ 0,\ \ \ \ \ \ \ \ \ \ \ \ White,\ \ \ \ \ \ \ \ \ \ \ \ Red,\ \ \ \ \ \ \ \ \ \ \ \ Green,\ \ \ \ \ \ \ \ \ \ \ \ Blue,\ \ \ \ \ \ \ \ \ \ \ \ Cyan,\ \ \ \ \ \ \ \ \ \ \ \ Yellow,\ \ \ \ \ \ \ \ \ \ \ \ Grey,\ \ \ \ \ \ \ \ \ \ \ \ Bright\ =\ 0x10,\ \ \ \ \ \ \ \ \ \ \ \ BrightRed\ =\ Bright\ |\ Red,\ \ \ \ \ \ \ \ \ \ \ \ BrightGreen\ =\ Bright\ |\ Green,\ \ \ \ \ \ \ \ \ \ \ \ LightGrey\ =\ Bright\ |\ Grey,\ \ \ \ \ \ \ \ \ \ \ \ BrightWhite\ =\ Bright\ |\ White,\ \ \ \ \ \ \ \ \ \ \ \ BrightYellow\ =\ Bright\ |\ Yellow,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FileName\ =\ LightGrey,\ \ \ \ \ \ \ \ \ \ \ \ Warning\ =\ BrightYellow,\ \ \ \ \ \ \ \ \ \ \ \ ResultError\ =\ BrightRed,\ \ \ \ \ \ \ \ \ \ \ \ ResultSuccess\ =\ BrightGreen,\ \ \ \ \ \ \ \ \ \ \ \ ResultExpectedFailure\ =\ Warning,\ \ \ \ \ \ \ \ \ \ \ \ Error\ =\ BrightRed,\ \ \ \ \ \ \ \ \ \ \ \ Success\ =\ Green,\ \ \ \ \ \ \ \ \ \ \ \ Skip\ =\ LightGrey,\ \ \ \ \ \ \ \ \ \ \ \ OriginalExpression\ =\ Cyan,\ \ \ \ \ \ \ \ \ \ \ \ ReconstructedExpression\ =\ BrightYellow,\ \ \ \ \ \ \ \ \ \ \ \ SecondaryText\ =\ LightGrey,\ \ \ \ \ \ \ \ \ \ \ \ Headers\ =\ White\ \ \ \ \ \ \ \ \};\ \ \ \ \};\ \ \ \ class\ ColourImpl\ \{\ \ \ \ protected:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IStream*\ m\_stream;\ \ \ \ public:\ \ \ \ \ \ \ \ ColourImpl(\ IStream*\ stream\ ):\ m\_stream(\ stream\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ class\ ColourGuard\ \{\ \ \ \ \ \ \ \ \ \ \ \ ColourImpl\ const*\ m\_colourImpl;\ \ \ \ \ \ \ \ \ \ \ \ Colour::Code\ m\_code;\ \ \ \ \ \ \ \ \ \ \ \ bool\ m\_engaged\ =\ false;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourGuard(\ Colour::Code\ code,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourImpl\ const*\ colour\ );\ \ \ \ \ \ \ \ \ \ \ \ ColourGuard(\ ColourGuard\ const\&\ rhs\ )\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\&\ operator=(\ ColourGuard\ const\&\ rhs\ )\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ ColourGuard(\ ColourGuard\&\&\ rhs\ )\ noexcept;\ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\&\ operator=(\ ColourGuard\&\&\ rhs\ )\ noexcept;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \string~ColourGuard();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\&\ engage(\ std::ostream\&\ stream\ )\ \&;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\&\&\ engage(\ std::ostream\&\ stream\ )\ \&\&;\ \ \ \ \ \ \ \ private:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator<<(\ std::ostream\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\&\ guard\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ guard.engageImpl(\ lhs\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ lhs;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator<<(\ std::ostream\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\&\&\ guard)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ guard.engageImpl(\ lhs\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ lhs;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ void\ engageImpl(\ std::ostream\&\ stream\ );\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ virtual\ \string~ColourImpl();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourGuard\ guardColour(\ Colour::Code\ colourCode\ );\ \ \ \ private:\ \ \ \ \ \ \ \ virtual\ void\ use(\ Colour::Code\ colourCode\ )\ const\ =\ 0;\ \ \ \ \};\ \ \ \ \ \ \ \ Detail::unique\_ptr<ColourImpl>\ makeColourImpl(\ ColourMode\ colourSelection,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IStream*\ stream\ );\ \ \ \ \ \ \ \ bool\ isColourImplAvailable(\ ColourMode\ colourSelection\ );\}\ \#endif\ \#ifndef\ CATCH\_CONSOLE\_WIDTH\_HPP\_INCLUDED\#define\ CATCH\_CONSOLE\_WIDTH\_HPP\_INCLUDED\#ifndef\ CATCH\_CONFIG\_CONSOLE\_WIDTH\#define\ CATCH\_CONFIG\_CONSOLE\_WIDTH\ 80\#endif\#endif\ \#ifndef\ CATCH\_CONTAINER\_NONMEMBERS\_HPP\_INCLUDED\#define\ CATCH\_CONTAINER\_NONMEMBERS\_HPP\_INCLUDED\#include\ <cstddef>\#include\ <initializer\_list>\#if\ defined(CATCH\_CPP17\_OR\_GREATER)\ ||\ defined(\_MSC\_VER)\#include\ <string>\#\ \ if\ !defined(\_\_cpp\_lib\_nonmember\_container\_access)\#\ \ \ \ \ \ define\ CATCH\_CONFIG\_POLYFILL\_NONMEMBER\_CONTAINER\_ACCESS\#\ \ endif\#else\#define\ CATCH\_CONFIG\_POLYFILL\_NONMEMBER\_CONTAINER\_ACCESS\#endifnamespace\ Catch\ \{namespace\ Detail\ \{\#if\ defined(CATCH\_CONFIG\_POLYFILL\_NONMEMBER\_CONTAINER\_ACCESS)\ \ \ \ template\ <typename\ Container>\ \ \ \ constexpr\ auto\ empty(Container\ const\&\ cont)\ -\/>\ decltype(cont.empty())\ \{\ \ \ \ \ \ \ \ return\ cont.empty();\ \ \ \ \}\ \ \ \ template\ <typename\ T,\ std::size\_t\ N>\ \ \ \ constexpr\ bool\ empty(const\ T\ (\&)[N])\ noexcept\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)N;\ \ \ \ \ \ \ \ return\ false;\ \ \ \ \}\ \ \ \ template\ <typename\ T>\ \ \ \ constexpr\ bool\ empty(std::initializer\_list<T>\ list)\ noexcept\ \{\ \ \ \ \ \ \ \ return\ list.size()\ >\ 0;\ \ \ \ \}\ \ \ \ template\ <typename\ Container>\ \ \ \ constexpr\ auto\ size(Container\ const\&\ cont)\ -\/>\ decltype(cont.size())\ \{\ \ \ \ \ \ \ \ return\ cont.size();\ \ \ \ \}\ \ \ \ template\ <typename\ T,\ std::size\_t\ N>\ \ \ \ constexpr\ std::size\_t\ size(const\ T(\&)[N])\ noexcept\ \{\ \ \ \ \ \ \ \ return\ N;\ \ \ \ \}\#endif\ \}\ \}\ \#endif\ \#ifndef\ CATCH\_DEBUG\_CONSOLE\_HPP\_INCLUDED\#define\ CATCH\_DEBUG\_CONSOLE\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\ \ \ \ void\ writeToDebugConsole(\ std::string\ const\&\ text\ );\}\#endif\ \#ifndef\ CATCH\_DEBUGGER\_HPP\_INCLUDED\#define\ CATCH\_DEBUGGER\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ bool\ isDebuggerActive();\}\#ifdef\ CATCH\_PLATFORM\_MAC\ \ \ \ \#if\ defined(\_\_i386\_\_)\ ||\ defined(\_\_x86\_64\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \_\_asm\_\_("{}int\ \$3\(\backslash\)n"{}\ :\ :\ )\ \ \ \ \ \#elif\ defined(\_\_aarch64\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \_\_asm\_\_("{}.inst\ 0xd43e0000"{})\ \ \ \ \#elif\ defined(\_\_POWERPC\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \_\_asm\_\_("{}li\ r0,\ 20\(\backslash\)nsc\(\backslash\)nnop\(\backslash\)nli\ r0,\ 37\(\backslash\)nli\ r4,\ 2\(\backslash\)nsc\(\backslash\)nnop\(\backslash\)n"{}\ \(\backslash\)\ \ \ \ \ \ \ \ :\ :\ :\ "{}memory"{},"{}r0"{},"{}r3"{},"{}r4"{}\ )\ \ \ \ \ \#endif\#elif\ defined(CATCH\_PLATFORM\_IPHONE)\ \ \ \ \ \ \ \ \#if\ defined(\_\_i386\_\_)\ ||\ defined(\_\_x86\_64\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \ \_\_asm\_\_("{}int\ \$3"{})\ \ \ \ \#elif\ defined(\_\_aarch64\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \ \_\_asm\_\_("{}.inst\ 0xd4200000"{})\ \ \ \ \#elif\ defined(\_\_arm\_\_)\ \&\&\ !defined(\_\_thumb\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \ \_\_asm\_\_("{}.inst\ 0xe7f001f0"{})\ \ \ \ \#elif\ defined(\_\_arm\_\_)\ \&\&\ \ defined(\_\_thumb\_\_)\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ \ \_\_asm\_\_("{}.inst\ 0xde01"{})\ \ \ \ \#endif\#elif\ defined(CATCH\_PLATFORM\_LINUX)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \#if\ defined(\_\_GNUC\_\_)\ \&\&\ (defined(\_\_i386)\ ||\ defined(\_\_x86\_64))\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ asm\ volatile\ ("{}int\ \$3"{})\ \ \ \ \ \#else\ \ \ \ \ \ \ \ \ \#include\ <signal.h>\ \ \ \ \ \ \ \ \#define\ CATCH\_TRAP()\ raise(SIGTRAP)\ \ \ \ \#endif\#elif\ defined(\_MSC\_VER)\ \ \ \ \#define\ CATCH\_TRAP()\ \_\_debugbreak()\#elif\ defined(\_\_MINGW32\_\_)\ \ \ \ extern\ "{}C"{}\ \_\_declspec(dllimport)\ void\ \_\_stdcall\ DebugBreak();\ \ \ \ \#define\ CATCH\_TRAP()\ DebugBreak()\#endif\#ifndef\ CATCH\_BREAK\_INTO\_DEBUGGER\ \ \ \ \#ifdef\ CATCH\_TRAP\ \ \ \ \ \ \ \ \#define\ CATCH\_BREAK\_INTO\_DEBUGGER()\ []\{\ if(\ Catch::isDebuggerActive()\ )\ \{\ CATCH\_TRAP();\ \}\ \}()\ \ \ \ \#else\ \ \ \ \ \ \ \ \#define\ CATCH\_BREAK\_INTO\_DEBUGGER()\ []\{\}()\ \ \ \ \#endif\#endif\#endif\ \#ifndef\ CATCH\_ENFORCE\_HPP\_INCLUDED\#define\ CATCH\_ENFORCE\_HPP\_INCLUDED\#include\ <exception>namespace\ Catch\ \{\#if\ !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)\ \ \ \ template\ <typename\ Ex>\ \ \ \ [[noreturn]]\ \ \ \ void\ throw\_exception(Ex\ const\&\ e)\ \{\ \ \ \ \ \ \ \ throw\ e;\ \ \ \ \}\#else\ \ \ \ \ [[noreturn]]\ \ \ \ void\ throw\_exception(std::exception\ const\&\ e);\#endif\ \ \ \ [[noreturn]]\ \ \ \ void\ throw\_logic\_error(std::string\ const\&\ msg);\ \ \ \ [[noreturn]]\ \ \ \ void\ throw\_domain\_error(std::string\ const\&\ msg);\ \ \ \ [[noreturn]]\ \ \ \ void\ throw\_runtime\_error(std::string\ const\&\ msg);\}\ \#define\ CATCH\_MAKE\_MSG(...)\ \(\backslash\)\ \ \ \ (Catch::ReusableStringStream()\ <<\ \_\_VA\_ARGS\_\_).str()\#define\ CATCH\_INTERNAL\_ERROR(...)\ \(\backslash\)\ \ \ \ Catch::throw\_logic\_error(CATCH\_MAKE\_MSG(\ CATCH\_INTERNAL\_LINEINFO\ <<\ "{}:\ Internal\ Catch2\ error:\ "{}\ <<\ \_\_VA\_ARGS\_\_))\#define\ CATCH\_ERROR(...)\ \(\backslash\)\ \ \ \ Catch::throw\_domain\_error(CATCH\_MAKE\_MSG(\ \_\_VA\_ARGS\_\_\ ))\#define\ CATCH\_RUNTIME\_ERROR(...)\ \(\backslash\)\ \ \ \ Catch::throw\_runtime\_error(CATCH\_MAKE\_MSG(\ \_\_VA\_ARGS\_\_\ ))\#define\ CATCH\_ENFORCE(\ condition,\ ...\ )\ \(\backslash\)\ \ \ \ do\{\ if(\ !(condition)\ )\ CATCH\_ERROR(\ \_\_VA\_ARGS\_\_\ );\ \}\ while(false)\#endif\ \#ifndef\ CATCH\_ENUM\_VALUES\_REGISTRY\_HPP\_INCLUDED\#define\ CATCH\_ENUM\_VALUES\_REGISTRY\_HPP\_INCLUDED\#include\ <vector>namespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ Catch::Detail::unique\_ptr<EnumInfo>\ makeEnumInfo(\ StringRef\ enumName,\ StringRef\ allValueNames,\ std::vector<int>\ const\&\ values\ );\ \ \ \ \ \ \ \ class\ EnumValuesRegistry\ :\ public\ IMutableEnumValuesRegistry\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::vector<Catch::Detail::unique\_ptr<EnumInfo>>\ m\_enumInfos;\ \ \ \ \ \ \ \ \ \ \ \ EnumInfo\ const\&\ registerEnum(\ StringRef\ enumName,\ StringRef\ allValueNames,\ std::vector<int>\ const\&\ values)\ override;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ std::vector<StringRef>\ parseEnums(\ StringRef\ enums\ );\ \ \ \ \}\ \}\ \#endif\ \#ifndef\ CATCH\_ERRNO\_GUARD\_HPP\_INCLUDED\#define\ CATCH\_ERRNO\_GUARD\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ \ \ \ \ \ \ \ \ class\ ErrnoGuard\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ErrnoGuard();\ \ \ \ \ \ \ \ \string~ErrnoGuard();\ \ \ \ private:\ \ \ \ \ \ \ \ int\ m\_oldErrno;\ \ \ \ \};\}\#endif\ \#ifndef\ CATCH\_EXCEPTION\_TRANSLATOR\_REGISTRY\_HPP\_INCLUDED\#define\ CATCH\_EXCEPTION\_TRANSLATOR\_REGISTRY\_HPP\_INCLUDED\#include\ <vector>\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ ExceptionTranslatorRegistry\ :\ public\ IExceptionTranslatorRegistry\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ \string~ExceptionTranslatorRegistry()\ override;\ \ \ \ \ \ \ \ void\ registerTranslator(\ Detail::unique\_ptr<IExceptionTranslator>\&\&\ translator\ );\ \ \ \ \ \ \ \ std::string\ translateActiveException()\ const\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ ExceptionTranslators\ m\_translators;\ \ \ \ \};\}\#endif\ \#ifndef\ CATCH\_FATAL\_CONDITION\_HANDLER\_HPP\_INCLUDED\#define\ CATCH\_FATAL\_CONDITION\_HANDLER\_HPP\_INCLUDED\#include\ <cassert>namespace\ Catch\ \{\ \ \ \ \ \ \ \ class\ FatalConditionHandler\ \{\ \ \ \ \ \ \ \ bool\ m\_started\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ engage\_platform();\ \ \ \ \ \ \ \ void\ disengage\_platform()\ noexcept;\ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FatalConditionHandler();\ \ \ \ \ \ \ \ \string~FatalConditionHandler();\ \ \ \ \ \ \ \ void\ engage()\ \{\ \ \ \ \ \ \ \ \ \ \ \ assert(!m\_started\ \&\&\ "{}Handler\ cannot\ be\ installed\ twice."{});\ \ \ \ \ \ \ \ \ \ \ \ m\_started\ =\ true;\ \ \ \ \ \ \ \ \ \ \ \ engage\_platform();\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ disengage()\ noexcept\ \{\ \ \ \ \ \ \ \ \ \ \ \ assert(m\_started\ \&\&\ "{}Handler\ cannot\ be\ uninstalled\ without\ being\ installed\ first"{});\ \ \ \ \ \ \ \ \ \ \ \ m\_started\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ disengage\_platform();\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ \ \ \ \ class\ FatalConditionHandlerGuard\ \{\ \ \ \ \ \ \ \ FatalConditionHandler*\ m\_handler;\ \ \ \ public:\ \ \ \ \ \ \ \ FatalConditionHandlerGuard(FatalConditionHandler*\ handler):\ \ \ \ \ \ \ \ \ \ \ \ m\_handler(handler)\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_handler-\/>engage();\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \string~FatalConditionHandlerGuard()\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_handler-\/>disengage();\ \ \ \ \ \ \ \ \}\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_FLOATING\_POINT\_HELPERS\_HPP\_INCLUDED\#define\ CATCH\_FLOATING\_POINT\_HELPERS\_HPP\_INCLUDED\#include\ <cassert>\#include\ <cmath>\#include\ <cstdint>\#include\ <utility>\#include\ <limits>namespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ uint32\_t\ convertToBits(float\ f);\ \ \ \ \ \ \ \ uint64\_t\ convertToBits(double\ d);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ directCompare(\ float\ lhs,\ float\ rhs\ );\ \ \ \ \ \ \ \ bool\ directCompare(\ double\ lhs,\ double\ rhs\ );\ \ \ \ \}\ \#if\ defined(\ \_\_GNUC\_\_\ )\ ||\ defined(\ \_\_clang\_\_\ )\#\ \ \ \ pragma\ GCC\ diagnostic\ push\ \ \ \ \ \ \ \ \ \ \ \ \#\ \ \ \ pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wfloat-\/equal"{}\#endif\ \ \ \ \ \ \ \ template\ <typename\ FP>\ \ \ \ uint64\_t\ ulpDistance(\ FP\ lhs,\ FP\ rhs\ )\ \{\ \ \ \ \ \ \ \ assert(\ std::numeric\_limits<FP>::is\_iec559\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ "{}ulpDistance\ assumes\ IEEE-\/754\ format\ for\ floating\ point\ types"{}\ );\ \ \ \ \ \ \ \ assert(\ !Catch::isnan(\ lhs\ )\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}Distance\ between\ NaN\ and\ number\ is\ not\ meaningful"{}\ );\ \ \ \ \ \ \ \ assert(\ !Catch::isnan(\ rhs\ )\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}Distance\ between\ NaN\ and\ number\ is\ not\ meaningful"{}\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ lhs\ ==\ rhs\ )\ \{\ return\ 0;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\ constexpr\ FP\ positive\_zero\{\};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ lhs\ ==\ positive\_zero\ )\ \{\ lhs\ =\ positive\_zero;\ \}\ \ \ \ \ \ \ \ if\ (\ rhs\ ==\ positive\_zero\ )\ \{\ rhs\ =\ positive\_zero;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ std::signbit(\ lhs\ )\ !=\ std::signbit(\ rhs\ )\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ ulpDistance(\ std::abs(\ lhs\ ),\ positive\_zero\ )\ +\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ulpDistance(\ std::abs(\ rhs\ ),\ positive\_zero\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ lc\ =\ Detail::convertToBits(\ lhs\ );\ \ \ \ \ \ \ \ uint64\_t\ rc\ =\ Detail::convertToBits(\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ lc\ <\ rc\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::swap(\ lc,\ rc\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ return\ lc\ -\/\ rc;\ \ \ \ \}\#if\ defined(\ \_\_GNUC\_\_\ )\ ||\ defined(\ \_\_clang\_\_\ )\#\ \ \ \ pragma\ GCC\ diagnostic\ pop\#endif\}\ \#endif\ \#ifndef\ CATCH\_GETENV\_HPP\_INCLUDED\#define\ CATCH\_GETENV\_HPP\_INCLUDEDnamespace\ Catch\ \{namespace\ Detail\ \{\ \ \ \ \ \ \ \ char\ const*\ getEnv(char\ const*\ varName);\}\}\#endif\ \#ifndef\ CATCH\_IS\_PERMUTATION\_HPP\_INCLUDED\#define\ CATCH\_IS\_PERMUTATION\_HPP\_INCLUDED\#include\ <algorithm>\#include\ <iterator>namespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ template\ <typename\ ForwardIter,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Sentinel,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Comparator>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ ForwardIter\ find\_sentinel(\ ForwardIter\ start,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Sentinel\ sentinel,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\ const\&\ value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Comparator\ cmp\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ while\ (\ start\ !=\ sentinel\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ cmp(\ *start,\ value\ )\ )\ \{\ break;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++start;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ start;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ ForwardIter,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Sentinel,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Comparator>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ std::ptrdiff\_t\ count\_sentinel(\ ForwardIter\ start,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Sentinel\ sentinel,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\ const\&\ value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Comparator\ cmp\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::ptrdiff\_t\ count\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ while\ (\ start\ !=\ sentinel\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ cmp(\ *start,\ value\ )\ )\ \{\ ++count;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++start;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ count;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ ForwardIter,\ typename\ Sentinel>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ std::enable\_if\_t<!std::is\_same<ForwardIter,\ Sentinel>::value,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::ptrdiff\_t>\ \ \ \ \ \ \ \ sentinel\_distance(\ ForwardIter\ iter,\ const\ Sentinel\ sentinel\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::ptrdiff\_t\ dist\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ while\ (\ iter\ !=\ sentinel\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++iter;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++dist;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ dist;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ ForwardIter>\ \ \ \ \ \ \ \ constexpr\ std::ptrdiff\_t\ sentinel\_distance(\ ForwardIter\ first,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ForwardIter\ last\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ std::distance(\ first,\ last\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ ForwardIter1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Sentinel1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ ForwardIter2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Sentinel2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Comparator>\ \ \ \ \ \ \ \ constexpr\ bool\ check\_element\_counts(\ ForwardIter1\ first\_1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Sentinel1\ end\_1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ForwardIter2\ first\_2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Sentinel2\ end\_2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Comparator\ cmp\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ auto\ cursor\ =\ first\_1;\ \ \ \ \ \ \ \ \ \ \ \ while\ (\ cursor\ !=\ end\_1\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ find\_sentinel(\ first\_1,\ cursor,\ *cursor,\ cmp\ )\ ==\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cursor\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ count\_in\_range\_2\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count\_sentinel(\ first\_2,\ end\_2,\ *cursor,\ cmp\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ count\_in\_range\_2\ ==\ 0\ )\ \{\ return\ false;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ count\_in\_range\_1\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count\_sentinel(\ cursor,\ end\_1,\ *cursor,\ cmp\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ count\_in\_range\_1\ !=\ count\_in\_range\_2\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++cursor;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ ForwardIter1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Sentinel1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ ForwardIter2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Sentinel2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Comparator>\ \ \ \ \ \ \ \ constexpr\ bool\ is\_permutation(\ ForwardIter1\ first\_1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Sentinel1\ end\_1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ForwardIter2\ first\_2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Sentinel2\ end\_2,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Comparator\ cmp\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ while\ (first\_1\ !=\ end\_1\ \&\&\ first\_2\ !=\ end\_2\ \&\&\ cmp(*first\_1,\ *first\_2))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++first\_1;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++first\_2;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (first\_1\ ==\ end\_1\ ||\ first\_2\ ==\ end\_2)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ first\_1\ ==\ end\_1\ \&\&\ first\_2\ ==\ end\_2;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ dist\_1\ =\ sentinel\_distance(\ first\_1,\ end\_1\ );\ \ \ \ \ \ \ \ \ \ \ \ auto\ dist\_2\ =\ sentinel\_distance(\ first\_2,\ end\_2\ );\ \ \ \ \ \ \ \ \ \ \ \ if\ (dist\_1\ !=\ dist\_2)\ \{\ return\ false;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ check\_element\_counts(\ first\_1,\ end\_1,\ first\_2,\ end\_2,\ cmp\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \}\ \}\ \#endif\ \#ifndef\ CATCH\_ISTREAM\_HPP\_INCLUDED\#define\ CATCH\_ISTREAM\_HPP\_INCLUDED\#include\ <iosfwd>\#include\ <cstddef>\#include\ <ostream>\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ IStream\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ virtual\ \string~IStream();\ \ \ \ \ \ \ \ \ virtual\ std::ostream\&\ stream()\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ bool\ isConsole()\ const\ \{\ return\ false;\ \}\ \ \ \ \};\ \ \ \ \ \ \ \ auto\ makeStream(\ std::string\ const\&\ filename\ )\ -\/>\ Detail::unique\_ptr<IStream>;\}\#endif\ \#ifndef\ CATCH\_JSONWRITER\_HPP\_INCLUDED\#define\ CATCH\_JSONWRITER\_HPP\_INCLUDED\#include\ <cstdint>\#include\ <sstream>namespace\ Catch\ \{\ \ \ \ class\ JsonObjectWriter;\ \ \ \ class\ JsonArrayWriter;\ \ \ \ struct\ JsonUtils\ \{\ \ \ \ \ \ \ \ static\ void\ indent(\ std::ostream\&\ os,\ std::uint64\_t\ level\ );\ \ \ \ \ \ \ \ static\ void\ appendCommaNewline(\ std::ostream\&\ os,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\&\ should\_comma,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::uint64\_t\ level\ );\ \ \ \ \};\ \ \ \ class\ JsonValueWriter\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ JsonValueWriter(\ std::ostream\&\ os\ );\ \ \ \ \ \ \ \ JsonValueWriter(\ std::ostream\&\ os,\ std::uint64\_t\ indent\_level\ );\ \ \ \ \ \ \ \ JsonObjectWriter\ writeObject()\ \&\&;\ \ \ \ \ \ \ \ JsonArrayWriter\ writeArray()\ \&\&;\ \ \ \ \ \ \ \ template\ <typename\ T>\ \ \ \ \ \ \ \ void\ write(\ T\ const\&\ value\ )\ \&\&\ \{\ \ \ \ \ \ \ \ \ \ \ \ writeImpl(\ value,\ !std::is\_arithmetic<T>::value\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ write(\ StringRef\ value\ )\ \&\&;\ \ \ \ \ \ \ \ void\ write(\ bool\ value\ )\ \&\&;\ \ \ \ private:\ \ \ \ \ \ \ \ void\ writeImpl(\ StringRef\ value,\ bool\ quote\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ =\ typename\ std::enable\_if\_t<\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_convertible<T,\ StringRef>::value>>\ \ \ \ \ \ \ \ void\ writeImpl(\ T\ const\&\ value,\ bool\ quote\_value\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_sstream\ <<\ value;\ \ \ \ \ \ \ \ \ \ \ \ writeImpl(\ m\_sstream.str(),\ quote\_value\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::ostream\&\ m\_os;\ \ \ \ \ \ \ \ std::stringstream\ m\_sstream;\ \ \ \ \ \ \ \ std::uint64\_t\ m\_indent\_level;\ \ \ \ \};\ \ \ \ class\ JsonObjectWriter\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ JsonObjectWriter(\ std::ostream\&\ os\ );\ \ \ \ \ \ \ \ JsonObjectWriter(\ std::ostream\&\ os,\ std::uint64\_t\ indent\_level\ );\ \ \ \ \ \ \ \ JsonObjectWriter(\ JsonObjectWriter\&\&\ source\ )\ noexcept;\ \ \ \ \ \ \ \ JsonObjectWriter\&\ operator=(\ JsonObjectWriter\&\&\ source\ )\ =\ delete;\ \ \ \ \ \ \ \ \string~JsonObjectWriter();\ \ \ \ \ \ \ \ JsonValueWriter\ write(\ StringRef\ key\ );\ \ \ \ private:\ \ \ \ \ \ \ \ std::ostream\&\ m\_os;\ \ \ \ \ \ \ \ std::uint64\_t\ m\_indent\_level;\ \ \ \ \ \ \ \ bool\ m\_should\_comma\ =\ false;\ \ \ \ \ \ \ \ bool\ m\_active\ =\ true;\ \ \ \ \};\ \ \ \ class\ JsonArrayWriter\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ JsonArrayWriter(\ std::ostream\&\ os\ );\ \ \ \ \ \ \ \ JsonArrayWriter(\ std::ostream\&\ os,\ std::uint64\_t\ indent\_level\ );\ \ \ \ \ \ \ \ JsonArrayWriter(\ JsonArrayWriter\&\&\ source\ )\ noexcept;\ \ \ \ \ \ \ \ JsonArrayWriter\&\ operator=(\ JsonArrayWriter\&\&\ source\ )\ =\ delete;\ \ \ \ \ \ \ \ \string~JsonArrayWriter();\ \ \ \ \ \ \ \ JsonObjectWriter\ writeObject();\ \ \ \ \ \ \ \ JsonArrayWriter\ writeArray();\ \ \ \ \ \ \ \ template\ <typename\ T>\ \ \ \ \ \ \ \ JsonArrayWriter\&\ write(\ T\ const\&\ value\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ writeImpl(\ value\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ JsonArrayWriter\&\ write(\ bool\ value\ );\ \ \ \ private:\ \ \ \ \ \ \ \ template\ <typename\ T>\ \ \ \ \ \ \ \ JsonArrayWriter\&\ writeImpl(\ T\ const\&\ value\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ JsonUtils::appendCommaNewline(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_os,\ m\_should\_comma,\ m\_indent\_level\ +\ 1\ );\ \ \ \ \ \ \ \ \ \ \ \ JsonValueWriter\{\ m\_os\ \}.write(\ value\ );\ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::ostream\&\ m\_os;\ \ \ \ \ \ \ \ std::uint64\_t\ m\_indent\_level;\ \ \ \ \ \ \ \ bool\ m\_should\_comma\ =\ false;\ \ \ \ \ \ \ \ bool\ m\_active\ =\ true;\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_LEAK\_DETECTOR\_HPP\_INCLUDED\#define\ CATCH\_LEAK\_DETECTOR\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ struct\ LeakDetector\ \{\ \ \ \ \ \ \ \ LeakDetector();\ \ \ \ \ \ \ \ \string~LeakDetector();\ \ \ \ \};\}\#endif\ \#ifndef\ CATCH\_LIST\_HPP\_INCLUDED\#define\ CATCH\_LIST\_HPP\_INCLUDED\#include\ <set>\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ IEventListener;\ \ \ \ class\ Config;\ \ \ \ struct\ ReporterDescription\ \{\ \ \ \ \ \ \ \ std::string\ name,\ description;\ \ \ \ \};\ \ \ \ struct\ ListenerDescription\ \{\ \ \ \ \ \ \ \ StringRef\ name;\ \ \ \ \ \ \ \ std::string\ description;\ \ \ \ \};\ \ \ \ struct\ TagInfo\ \{\ \ \ \ \ \ \ \ void\ add(StringRef\ spelling);\ \ \ \ \ \ \ \ std::string\ all()\ const;\ \ \ \ \ \ \ \ std::set<StringRef>\ spellings;\ \ \ \ \ \ \ \ std::size\_t\ count\ =\ 0;\ \ \ \ \};\ \ \ \ bool\ list(\ IEventListener\&\ reporter,\ Config\ const\&\ config\ );\}\ \#endif\ \#ifndef\ CATCH\_OUTPUT\_REDIRECT\_HPP\_INCLUDED\#define\ CATCH\_OUTPUT\_REDIRECT\_HPP\_INCLUDED\#include\ <cassert>\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ OutputRedirect\ \{\ \ \ \ \ \ \ \ bool\ m\_redirectActive\ =\ false;\ \ \ \ \ \ \ \ virtual\ void\ activateImpl()\ =\ 0;\ \ \ \ \ \ \ \ virtual\ void\ deactivateImpl()\ =\ 0;\ \ \ \ public:\ \ \ \ \ \ \ \ enum\ Kind\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ None,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Streams,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FileDescriptors,\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ virtual\ \string~OutputRedirect();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ std::string\ getStdout()\ =\ 0;\ \ \ \ \ \ \ \ virtual\ std::string\ getStderr()\ =\ 0;\ \ \ \ \ \ \ \ virtual\ void\ clearBuffers()\ =\ 0;\ \ \ \ \ \ \ \ bool\ isActive()\ const\ \{\ return\ m\_redirectActive;\ \}\ \ \ \ \ \ \ \ void\ activate()\ \{\ \ \ \ \ \ \ \ \ \ \ \ assert(\ !m\_redirectActive\ \&\&\ "{}redirect\ is\ already\ active"{}\ );\ \ \ \ \ \ \ \ \ \ \ \ activateImpl();\ \ \ \ \ \ \ \ \ \ \ \ m\_redirectActive\ =\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ deactivate()\ \{\ \ \ \ \ \ \ \ \ \ \ \ assert(\ m\_redirectActive\ \&\&\ "{}redirect\ is\ not\ active"{}\ );\ \ \ \ \ \ \ \ \ \ \ \ deactivateImpl();\ \ \ \ \ \ \ \ \ \ \ \ m\_redirectActive\ =\ false;\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ bool\ isRedirectAvailable(\ OutputRedirect::Kind\ kind);\ \ \ \ Detail::unique\_ptr<OutputRedirect>\ makeOutputRedirect(\ bool\ actual\ );\ \ \ \ class\ RedirectGuard\ \{\ \ \ \ \ \ \ \ OutputRedirect*\ m\_redirect;\ \ \ \ \ \ \ \ bool\ m\_activate;\ \ \ \ \ \ \ \ bool\ m\_previouslyActive;\ \ \ \ \ \ \ \ bool\ m\_moved\ =\ false;\ \ \ \ public:\ \ \ \ \ \ \ \ RedirectGuard(\ bool\ activate,\ OutputRedirect\&\ redirectImpl\ );\ \ \ \ \ \ \ \ \string~RedirectGuard()\ noexcept(\ false\ );\ \ \ \ \ \ \ \ RedirectGuard(\ RedirectGuard\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ RedirectGuard\&\ operator=(\ RedirectGuard\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ RedirectGuard(\ RedirectGuard\&\&\ rhs\ )\ noexcept;\ \ \ \ \ \ \ \ RedirectGuard\&\ operator=(\ RedirectGuard\&\&\ rhs\ )\ noexcept;\ \ \ \ \};\ \ \ \ RedirectGuard\ scopedActivate(\ OutputRedirect\&\ redirectImpl\ );\ \ \ \ RedirectGuard\ scopedDeactivate(\ OutputRedirect\&\ redirectImpl\ );\}\ \#endif\ \#ifndef\ CATCH\_PARSE\_NUMBERS\_HPP\_INCLUDED\#define\ CATCH\_PARSE\_NUMBERS\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\ \ \ \ \ \ \ \ Optional<unsigned\ int>\ parseUInt(std::string\ const\&\ input,\ int\ base\ =\ 10);\}\#endif\ \#ifndef\ CATCH\_REPORTER\_REGISTRY\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_REGISTRY\_HPP\_INCLUDED\#include\ <map>\#include\ <string>\#include\ <vector>namespace\ Catch\ \{\ \ \ \ class\ IEventListener;\ \ \ \ using\ IEventListenerPtr\ =\ Detail::unique\_ptr<IEventListener>;\ \ \ \ class\ IReporterFactory;\ \ \ \ using\ IReporterFactoryPtr\ =\ Detail::unique\_ptr<IReporterFactory>;\ \ \ \ struct\ ReporterConfig;\ \ \ \ class\ EventListenerFactory;\ \ \ \ class\ ReporterRegistry\ \{\ \ \ \ \ \ \ \ struct\ ReporterRegistryImpl;\ \ \ \ \ \ \ \ Detail::unique\_ptr<ReporterRegistryImpl>\ m\_impl;\ \ \ \ public:\ \ \ \ \ \ \ \ ReporterRegistry();\ \ \ \ \ \ \ \ \string~ReporterRegistry();\ \ \ \ \ \ \ \ \ IEventListenerPtr\ create(\ std::string\ const\&\ name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ReporterConfig\&\&\ config\ )\ const;\ \ \ \ \ \ \ \ void\ registerReporter(\ std::string\ const\&\ name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IReporterFactoryPtr\ factory\ );\ \ \ \ \ \ \ \ void\ \ \ \ \ \ \ \ registerListener(\ Detail::unique\_ptr<EventListenerFactory>\ factory\ );\ \ \ \ \ \ \ \ std::map<std::string,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IReporterFactoryPtr,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::CaseInsensitiveLess>\ const\&\ \ \ \ \ \ \ \ getFactories()\ const;\ \ \ \ \ \ \ \ std::vector<Detail::unique\_ptr<EventListenerFactory>>\ const\&\ \ \ \ \ \ \ \ getListeners()\ const;\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_RUN\_CONTEXT\_HPP\_INCLUDED\#define\ CATCH\_RUN\_CONTEXT\_HPP\_INCLUDED\#ifndef\ CATCH\_TEST\_CASE\_TRACKER\_HPP\_INCLUDED\#define\ CATCH\_TEST\_CASE\_TRACKER\_HPP\_INCLUDED\#include\ <string>\#include\ <vector>namespace\ Catch\ \{namespace\ TestCaseTracking\ \{\ \ \ \ struct\ NameAndLocation\ \{\ \ \ \ \ \ \ \ std::string\ name;\ \ \ \ \ \ \ \ SourceLineInfo\ location;\ \ \ \ \ \ \ \ NameAndLocation(\ std::string\&\&\ \_name,\ SourceLineInfo\ const\&\ \_location\ );\ \ \ \ \ \ \ \ friend\ bool\ operator==(NameAndLocation\ const\&\ lhs,\ NameAndLocation\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ lhs.location.line\ !=\ rhs.location.line\ )\ \{\ return\ false;\ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ lhs.name\ ==\ rhs.name\ \&\&\ lhs.location\ ==\ rhs.location;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ friend\ bool\ operator!=(NameAndLocation\ const\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ NameAndLocation\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ !(\ lhs\ ==\ rhs\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ \ \ \ \ struct\ NameAndLocationRef\ \{\ \ \ \ \ \ \ \ StringRef\ name;\ \ \ \ \ \ \ \ SourceLineInfo\ location;\ \ \ \ \ \ \ \ constexpr\ NameAndLocationRef(\ StringRef\ name\_,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SourceLineInfo\ location\_\ ):\ \ \ \ \ \ \ \ \ \ \ \ name(\ name\_\ ),\ location(\ location\_\ )\ \{\}\ \ \ \ \ \ \ \ friend\ bool\ operator==(\ NameAndLocation\ const\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ NameAndLocationRef\ const\&\ rhs\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ lhs.location.line\ !=\ rhs.location.line\ )\ \{\ return\ false;\ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ StringRef(\ lhs.name\ )\ ==\ rhs.name\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs.location\ ==\ rhs.location;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ friend\ bool\ operator==(\ NameAndLocationRef\ const\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ NameAndLocation\ const\&\ rhs\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ rhs\ ==\ lhs;\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ class\ ITracker;\ \ \ \ using\ ITrackerPtr\ =\ Catch::Detail::unique\_ptr<ITracker>;\ \ \ \ class\ ITracker\ \{\ \ \ \ \ \ \ \ NameAndLocation\ m\_nameAndLocation;\ \ \ \ \ \ \ \ using\ Children\ =\ std::vector<ITrackerPtr>;\ \ \ \ protected:\ \ \ \ \ \ \ \ enum\ CycleState\ \{\ \ \ \ \ \ \ \ \ \ \ \ NotStarted,\ \ \ \ \ \ \ \ \ \ \ \ Executing,\ \ \ \ \ \ \ \ \ \ \ \ ExecutingChildren,\ \ \ \ \ \ \ \ \ \ \ \ NeedsAnotherRun,\ \ \ \ \ \ \ \ \ \ \ \ CompletedSuccessfully,\ \ \ \ \ \ \ \ \ \ \ \ Failed\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ ITracker*\ m\_parent\ =\ nullptr;\ \ \ \ \ \ \ \ Children\ m\_children;\ \ \ \ \ \ \ \ CycleState\ m\_runState\ =\ NotStarted;\ \ \ \ public:\ \ \ \ \ \ \ \ ITracker(\ NameAndLocation\&\&\ nameAndLoc,\ ITracker*\ parent\ ):\ \ \ \ \ \ \ \ \ \ \ \ m\_nameAndLocation(\ CATCH\_MOVE(nameAndLoc)\ ),\ \ \ \ \ \ \ \ \ \ \ \ m\_parent(\ parent\ )\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ NameAndLocation\ const\&\ nameAndLocation()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ m\_nameAndLocation;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ ITracker*\ parent()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ m\_parent;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ virtual\ \string~ITracker();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ bool\ isComplete()\ const\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ isSuccessfullyCompleted()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ m\_runState\ ==\ CompletedSuccessfully;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ isOpen()\ const;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ hasStarted()\ const;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ close()\ =\ 0;\ \ \ \ \ \ \ \ \ virtual\ void\ fail()\ =\ 0;\ \ \ \ \ \ \ \ void\ markAsNeedingAnotherRun();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ addChild(\ ITrackerPtr\&\&\ child\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ITracker*\ findChild(\ NameAndLocationRef\ const\&\ nameAndLocation\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ hasChildren()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ !m\_children.empty();\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ openChild();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ bool\ isSectionTracker()\ const;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ bool\ isGeneratorTracker()\ const;\ \ \ \ \};\ \ \ \ class\ TrackerContext\ \{\ \ \ \ \ \ \ \ enum\ RunState\ \{\ \ \ \ \ \ \ \ \ \ \ \ NotStarted,\ \ \ \ \ \ \ \ \ \ \ \ Executing,\ \ \ \ \ \ \ \ \ \ \ \ CompletedCycle\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ ITrackerPtr\ m\_rootTracker;\ \ \ \ \ \ \ \ ITracker*\ m\_currentTracker\ =\ nullptr;\ \ \ \ \ \ \ \ RunState\ m\_runState\ =\ NotStarted;\ \ \ \ public:\ \ \ \ \ \ \ \ ITracker\&\ startRun();\ \ \ \ \ \ \ \ void\ startCycle()\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_currentTracker\ =\ m\_rootTracker.get();\ \ \ \ \ \ \ \ \ \ \ \ m\_runState\ =\ Executing;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ completeCycle();\ \ \ \ \ \ \ \ bool\ completedCycle()\ const;\ \ \ \ \ \ \ \ ITracker\&\ currentTracker()\ \{\ return\ *m\_currentTracker;\ \}\ \ \ \ \ \ \ \ void\ setCurrentTracker(\ ITracker*\ tracker\ );\ \ \ \ \};\ \ \ \ class\ TrackerBase\ :\ public\ ITracker\ \{\ \ \ \ protected:\ \ \ \ \ \ \ \ TrackerContext\&\ m\_ctx;\ \ \ \ public:\ \ \ \ \ \ \ \ TrackerBase(\ NameAndLocation\&\&\ nameAndLocation,\ TrackerContext\&\ ctx,\ ITracker*\ parent\ );\ \ \ \ \ \ \ \ bool\ isComplete()\ const\ override;\ \ \ \ \ \ \ \ void\ open();\ \ \ \ \ \ \ \ void\ close()\ override;\ \ \ \ \ \ \ \ void\ fail()\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ void\ moveToParent();\ \ \ \ \ \ \ \ void\ moveToThis();\ \ \ \ \};\ \ \ \ class\ SectionTracker\ :\ public\ TrackerBase\ \{\ \ \ \ \ \ \ \ std::vector<StringRef>\ m\_filters;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StringRef\ m\_trimmed\_name;\ \ \ \ public:\ \ \ \ \ \ \ \ SectionTracker(\ NameAndLocation\&\&\ nameAndLocation,\ TrackerContext\&\ ctx,\ ITracker*\ parent\ );\ \ \ \ \ \ \ \ bool\ isSectionTracker()\ const\ override;\ \ \ \ \ \ \ \ bool\ isComplete()\ const\ override;\ \ \ \ \ \ \ \ static\ SectionTracker\&\ acquire(\ TrackerContext\&\ ctx,\ NameAndLocationRef\ const\&\ nameAndLocation\ );\ \ \ \ \ \ \ \ void\ tryOpen();\ \ \ \ \ \ \ \ void\ addInitialFilters(\ std::vector<std::string>\ const\&\ filters\ );\ \ \ \ \ \ \ \ void\ addNextFilters(\ std::vector<StringRef>\ const\&\ filters\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<StringRef>\ const\&\ getFilters()\ const\ \{\ return\ m\_filters;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StringRef\ trimmedName()\ const;\ \ \ \ \};\}\ using\ TestCaseTracking::ITracker;using\ TestCaseTracking::TrackerContext;using\ TestCaseTracking::SectionTracker;\}\ \#endif\ \#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ IGeneratorTracker;\ \ \ \ class\ IConfig;\ \ \ \ class\ IEventListener;\ \ \ \ using\ IEventListenerPtr\ =\ Detail::unique\_ptr<IEventListener>;\ \ \ \ class\ OutputRedirect;\ \ \ \ \ \ \ \ class\ RunContext\ final\ :\ public\ IResultCapture\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ RunContext(\ RunContext\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ RunContext\&\ operator\ =(\ RunContext\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ explicit\ RunContext(\ IConfig\ const*\ \_config,\ IEventListenerPtr\&\&\ reporter\ );\ \ \ \ \ \ \ \ \string~RunContext()\ override;\ \ \ \ \ \ \ \ Totals\ runTest(TestCaseHandle\ const\&\ testCase);\ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ handleExpr\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\&\ info,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ITransientExpression\ const\&\ expr,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AssertionReaction\&\ reaction\ )\ override;\ \ \ \ \ \ \ \ void\ handleMessage\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\&\ info,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ResultWas::OfType\ resultType,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\&\&\ message,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AssertionReaction\&\ reaction\ )\ override;\ \ \ \ \ \ \ \ void\ handleUnexpectedExceptionNotThrown\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\&\ info,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AssertionReaction\&\ reaction\ )\ override;\ \ \ \ \ \ \ \ void\ handleUnexpectedInflightException\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\&\ info,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\&\&\ message,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AssertionReaction\&\ reaction\ )\ override;\ \ \ \ \ \ \ \ void\ handleIncomplete\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\&\ info\ )\ override;\ \ \ \ \ \ \ \ void\ handleNonExpr\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\ \&info,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ResultWas::OfType\ resultType,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AssertionReaction\ \&reaction\ )\ override;\ \ \ \ \ \ \ \ void\ notifyAssertionStarted(\ AssertionInfo\ const\&\ info\ )\ override;\ \ \ \ \ \ \ \ bool\ sectionStarted(\ StringRef\ sectionName,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SourceLineInfo\ const\&\ sectionLineInfo,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Counts\&\ assertions\ )\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(\ SectionEndInfo\&\&\ endInfo\ )\ override;\ \ \ \ \ \ \ \ void\ sectionEndedEarly(\ SectionEndInfo\&\&\ endInfo\ )\ override;\ \ \ \ \ \ \ \ IGeneratorTracker*\ \ \ \ \ \ \ \ acquireGeneratorTracker(\ StringRef\ generatorName,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SourceLineInfo\ const\&\ lineInfo\ )\ override;\ \ \ \ \ \ \ \ IGeneratorTracker*\ createGeneratorTracker(\ \ \ \ \ \ \ \ \ \ \ \ StringRef\ generatorName,\ \ \ \ \ \ \ \ \ \ \ \ SourceLineInfo\ lineInfo,\ \ \ \ \ \ \ \ \ \ \ \ Generators::GeneratorBasePtr\&\&\ generator\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ name\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ info\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ stats\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ pushScopedMessage(\ MessageInfo\ const\&\ message\ )\ override;\ \ \ \ \ \ \ \ void\ popScopedMessage(\ MessageInfo\ const\&\ message\ )\ override;\ \ \ \ \ \ \ \ void\ emplaceUnscopedMessage(\ MessageBuilder\&\&\ builder\ )\ override;\ \ \ \ \ \ \ \ std::string\ getCurrentTestName()\ const\ override;\ \ \ \ \ \ \ \ const\ AssertionResult*\ getLastResult()\ const\ override;\ \ \ \ \ \ \ \ void\ exceptionEarlyReported()\ override;\ \ \ \ \ \ \ \ void\ handleFatalErrorCondition(\ StringRef\ message\ )\ override;\ \ \ \ \ \ \ \ bool\ lastAssertionPassed()\ override;\ \ \ \ \ \ \ \ void\ assertionPassed()\ override;\ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ aborting()\ const;\ \ \ \ private:\ \ \ \ \ \ \ \ void\ runCurrentTest();\ \ \ \ \ \ \ \ void\ invokeActiveTestCase();\ \ \ \ \ \ \ \ void\ resetAssertionInfo();\ \ \ \ \ \ \ \ bool\ testForMissingAssertions(\ Counts\&\ assertions\ );\ \ \ \ \ \ \ \ void\ assertionEnded(\ AssertionResult\&\&\ result\ );\ \ \ \ \ \ \ \ void\ reportExpr\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ \ \ AssertionInfo\ const\ \&info,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ResultWas::OfType\ resultType,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ITransientExpression\ const\ *expr,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ negated\ );\ \ \ \ \ \ \ \ void\ populateReaction(\ AssertionReaction\&\ reaction\ );\ \ \ \ private:\ \ \ \ \ \ \ \ void\ handleUnfinishedSections();\ \ \ \ \ \ \ \ TestRunInfo\ m\_runInfo;\ \ \ \ \ \ \ \ TestCaseHandle\ const*\ m\_activeTestCase\ =\ nullptr;\ \ \ \ \ \ \ \ ITracker*\ m\_testCaseTracker\ =\ nullptr;\ \ \ \ \ \ \ \ Optional<AssertionResult>\ m\_lastResult;\ \ \ \ \ \ \ \ IConfig\ const*\ m\_config;\ \ \ \ \ \ \ \ Totals\ m\_totals;\ \ \ \ \ \ \ \ IEventListenerPtr\ m\_reporter;\ \ \ \ \ \ \ \ std::vector<MessageInfo>\ m\_messages;\ \ \ \ \ \ \ \ std::vector<ScopedMessage>\ m\_messageScopes;\ \ \ \ \ \ \ \ \ AssertionInfo\ m\_lastAssertionInfo;\ \ \ \ \ \ \ \ std::vector<SectionEndInfo>\ m\_unfinishedSections;\ \ \ \ \ \ \ \ std::vector<ITracker*>\ m\_activeSections;\ \ \ \ \ \ \ \ TrackerContext\ m\_trackerContext;\ \ \ \ \ \ \ \ Detail::unique\_ptr<OutputRedirect>\ m\_outputRedirect;\ \ \ \ \ \ \ \ FatalConditionHandler\ m\_fatalConditionhandler;\ \ \ \ \ \ \ \ bool\ m\_lastAssertionPassed\ =\ false;\ \ \ \ \ \ \ \ bool\ m\_shouldReportUnexpected\ =\ true;\ \ \ \ \ \ \ \ bool\ m\_includeSuccessfulResults;\ \ \ \ \};\ \ \ \ void\ seedRng(IConfig\ const\&\ config);\ \ \ \ unsigned\ int\ rngSeed();\}\ \#endif\ \#ifndef\ CATCH\_SHARDING\_HPP\_INCLUDED\#define\ CATCH\_SHARDING\_HPP\_INCLUDED\#include\ <cassert>\#include\ <cmath>\#include\ <algorithm>namespace\ Catch\ \{\ \ \ \ template<typename\ Container>\ \ \ \ Container\ createShard(Container\ const\&\ container,\ std::size\_t\ const\ shardCount,\ std::size\_t\ const\ shardIndex)\ \{\ \ \ \ \ \ \ \ assert(shardCount\ >\ shardIndex);\ \ \ \ \ \ \ \ if\ (shardCount\ ==\ 1)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ container;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ const\ std::size\_t\ totalTestCount\ =\ container.size();\ \ \ \ \ \ \ \ const\ std::size\_t\ shardSize\ =\ totalTestCount\ /\ shardCount;\ \ \ \ \ \ \ \ const\ std::size\_t\ leftoverTests\ =\ totalTestCount\ \%\ shardCount;\ \ \ \ \ \ \ \ const\ std::size\_t\ startIndex\ =\ shardIndex\ *\ shardSize\ +\ (std::min)(shardIndex,\ leftoverTests);\ \ \ \ \ \ \ \ const\ std::size\_t\ endIndex\ =\ (shardIndex\ +\ 1)\ *\ shardSize\ +\ (std::min)(shardIndex\ +\ 1,\ leftoverTests);\ \ \ \ \ \ \ \ auto\ startIterator\ =\ std::next(container.begin(),\ static\_cast<std::ptrdiff\_t>(startIndex));\ \ \ \ \ \ \ \ auto\ endIterator\ =\ std::next(container.begin(),\ static\_cast<std::ptrdiff\_t>(endIndex));\ \ \ \ \ \ \ \ return\ Container(startIterator,\ endIterator);\ \ \ \ \}\}\#endif\ \#ifndef\ CATCH\_SINGLETONS\_HPP\_INCLUDED\#define\ CATCH\_SINGLETONS\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ struct\ ISingleton\ \{\ \ \ \ \ \ \ \ virtual\ \string~ISingleton();\ \ \ \ \ \};\ \ \ \ void\ addSingleton(\ ISingleton*\ singleton\ );\ \ \ \ void\ cleanupSingletons();\ \ \ \ template<typename\ SingletonImplT,\ typename\ InterfaceT\ =\ SingletonImplT,\ typename\ MutableInterfaceT\ =\ InterfaceT>\ \ \ \ class\ Singleton\ :\ SingletonImplT,\ public\ ISingleton\ \{\ \ \ \ \ \ \ \ static\ auto\ getInternal()\ -\/>\ Singleton*\ \{\ \ \ \ \ \ \ \ \ \ \ \ static\ Singleton*\ s\_instance\ =\ nullptr;\ \ \ \ \ \ \ \ \ \ \ \ if(\ !s\_instance\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s\_instance\ =\ new\ Singleton;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ addSingleton(\ s\_instance\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ s\_instance;\ \ \ \ \ \ \ \ \}\ \ \ \ public:\ \ \ \ \ \ \ \ static\ auto\ get()\ -\/>\ InterfaceT\ const\&\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ *getInternal();\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ static\ auto\ getMutable()\ -\/>\ MutableInterfaceT\&\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ *getInternal();\ \ \ \ \ \ \ \ \}\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_STARTUP\_EXCEPTION\_REGISTRY\_HPP\_INCLUDED\#define\ CATCH\_STARTUP\_EXCEPTION\_REGISTRY\_HPP\_INCLUDED\#include\ <vector>\#include\ <exception>namespace\ Catch\ \{\ \ \ \ class\ StartupExceptionRegistry\ \{\#if\ !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)\ \ \ \ public:\ \ \ \ \ \ \ \ void\ add(std::exception\_ptr\ const\&\ exception)\ noexcept;\ \ \ \ \ \ \ \ std::vector<std::exception\_ptr>\ const\&\ getExceptions()\ const\ noexcept;\ \ \ \ private:\ \ \ \ \ \ \ \ std::vector<std::exception\_ptr>\ m\_exceptions;\#endif\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_STDSTREAMS\_HPP\_INCLUDED\#define\ CATCH\_STDSTREAMS\_HPP\_INCLUDED\#include\ <iosfwd>namespace\ Catch\ \{\ \ \ \ std::ostream\&\ cout();\ \ \ \ std::ostream\&\ cerr();\ \ \ \ std::ostream\&\ clog();\}\ \#endif\#ifndef\ CATCH\_STRING\_MANIP\_HPP\_INCLUDED\#define\ CATCH\_STRING\_MANIP\_HPP\_INCLUDED\#include\ <cstdint>\#include\ <string>\#include\ <iosfwd>\#include\ <vector>namespace\ Catch\ \{\ \ \ \ bool\ startsWith(\ std::string\ const\&\ s,\ std::string\ const\&\ prefix\ );\ \ \ \ bool\ startsWith(\ StringRef\ s,\ char\ prefix\ );\ \ \ \ bool\ endsWith(\ std::string\ const\&\ s,\ std::string\ const\&\ suffix\ );\ \ \ \ bool\ endsWith(\ std::string\ const\&\ s,\ char\ suffix\ );\ \ \ \ bool\ contains(\ std::string\ const\&\ s,\ std::string\ const\&\ infix\ );\ \ \ \ void\ toLowerInPlace(\ std::string\&\ s\ );\ \ \ \ std::string\ toLower(\ std::string\ const\&\ s\ );\ \ \ \ char\ toLower(\ char\ c\ );\ \ \ \ \ \ \ \ std::string\ trim(\ std::string\ const\&\ str\ );\ \ \ \ \ \ \ \ StringRef\ trim(StringRef\ ref);\ \ \ \ \ \ \ \ std::vector<StringRef>\ splitStringRef(\ StringRef\ str,\ char\ delimiter\ );\ \ \ \ bool\ replaceInPlace(\ std::string\&\ str,\ std::string\ const\&\ replaceThis,\ std::string\ const\&\ withThis\ );\ \ \ \ \ \ \ \ class\ pluralise\ \{\ \ \ \ \ \ \ \ std::uint64\_t\ m\_count;\ \ \ \ \ \ \ \ StringRef\ m\_label;\ \ \ \ public:\ \ \ \ \ \ \ \ constexpr\ pluralise(std::uint64\_t\ count,\ StringRef\ label):\ \ \ \ \ \ \ \ \ \ \ \ m\_count(count),\ \ \ \ \ \ \ \ \ \ \ \ m\_label(label)\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator\ <<\ (\ std::ostream\&\ os,\ pluralise\ const\&\ pluraliser\ );\ \ \ \ \};\}\#endif\ \#ifndef\ CATCH\_TAG\_ALIAS\_REGISTRY\_HPP\_INCLUDED\#define\ CATCH\_TAG\_ALIAS\_REGISTRY\_HPP\_INCLUDED\#include\ <map>\#include\ <string>namespace\ Catch\ \{\ \ \ \ struct\ SourceLineInfo;\ \ \ \ class\ TagAliasRegistry\ :\ public\ ITagAliasRegistry\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ \string~TagAliasRegistry()\ override;\ \ \ \ \ \ \ \ TagAlias\ const*\ find(\ std::string\ const\&\ alias\ )\ const\ override;\ \ \ \ \ \ \ \ std::string\ expandAliases(\ std::string\ const\&\ unexpandedTestSpec\ )\ const\ override;\ \ \ \ \ \ \ \ void\ add(\ std::string\ const\&\ alias,\ std::string\ const\&\ tag,\ SourceLineInfo\ const\&\ lineInfo\ );\ \ \ \ private:\ \ \ \ \ \ \ \ std::map<std::string,\ TagAlias>\ m\_registry;\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_TEST\_CASE\_INFO\_HASHER\_HPP\_INCLUDED\#define\ CATCH\_TEST\_CASE\_INFO\_HASHER\_HPP\_INCLUDED\#include\ <cstdint>namespace\ Catch\ \{\ \ \ \ struct\ TestCaseInfo;\ \ \ \ class\ TestCaseInfoHasher\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ using\ hash\_t\ =\ std::uint64\_t;\ \ \ \ \ \ \ \ TestCaseInfoHasher(\ hash\_t\ seed\ );\ \ \ \ \ \ \ \ uint32\_t\ operator()(\ TestCaseInfo\ const\&\ t\ )\ const;\ \ \ \ private:\ \ \ \ \ \ \ \ hash\_t\ m\_seed;\ \ \ \ \};\}\ \#endif\ \#ifndef\ CATCH\_TEST\_CASE\_REGISTRY\_IMPL\_HPP\_INCLUDED\#define\ CATCH\_TEST\_CASE\_REGISTRY\_IMPL\_HPP\_INCLUDED\#include\ <vector>namespace\ Catch\ \{\ \ \ \ class\ IConfig;\ \ \ \ class\ ITestInvoker;\ \ \ \ class\ TestCaseHandle;\ \ \ \ class\ TestSpec;\ \ \ \ std::vector<TestCaseHandle>\ sortTests(\ IConfig\ const\&\ config,\ std::vector<TestCaseHandle>\ const\&\ unsortedTestCases\ );\ \ \ \ bool\ isThrowSafe(\ TestCaseHandle\ const\&\ testCase,\ IConfig\ const\&\ config\ );\ \ \ \ std::vector<TestCaseHandle>\ filterTests(\ std::vector<TestCaseHandle>\ const\&\ testCases,\ TestSpec\ const\&\ testSpec,\ IConfig\ const\&\ config\ );\ \ \ \ std::vector<TestCaseHandle>\ const\&\ getAllTestCasesSorted(\ IConfig\ const\&\ config\ );\ \ \ \ class\ TestRegistry\ :\ public\ ITestCaseRegistry\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ void\ registerTest(\ Detail::unique\_ptr<TestCaseInfo>\ testInfo,\ Detail::unique\_ptr<ITestInvoker>\ testInvoker\ );\ \ \ \ \ \ \ \ std::vector<TestCaseInfo*>\ const\&\ getAllInfos()\ const\ override;\ \ \ \ \ \ \ \ std::vector<TestCaseHandle>\ const\&\ getAllTests()\ const\ override;\ \ \ \ \ \ \ \ std::vector<TestCaseHandle>\ const\&\ getAllTestsSorted(\ IConfig\ const\&\ config\ )\ const\ override;\ \ \ \ \ \ \ \ \string~TestRegistry()\ override;\ \ \ \ \ private:\ \ \ \ \ \ \ \ std::vector<Detail::unique\_ptr<TestCaseInfo>>\ m\_owned\_test\_infos;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<TestCaseInfo*>\ m\_viewed\_test\_infos;\ \ \ \ \ \ \ \ std::vector<Detail::unique\_ptr<ITestInvoker>>\ m\_invokers;\ \ \ \ \ \ \ \ std::vector<TestCaseHandle>\ m\_handles;\ \ \ \ \ \ \ \ mutable\ TestRunOrder\ m\_currentSortOrder\ =\ TestRunOrder::Declared;\ \ \ \ \ \ \ \ mutable\ std::vector<TestCaseHandle>\ m\_sortedFunctions;\ \ \ \ \};\ \ \ \ \}\ \#endif\ \#ifndef\ CATCH\_TEST\_SPEC\_PARSER\_HPP\_INCLUDED\#define\ CATCH\_TEST\_SPEC\_PARSER\_HPP\_INCLUDED\#ifdef\ \_\_clang\_\_\#pragma\ clang\ diagnostic\ push\#pragma\ clang\ diagnostic\ ignored\ "{}-\/Wpadded"{}\#endif\#include\ <vector>\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ ITagAliasRegistry;\ \ \ \ class\ TestSpecParser\ \{\ \ \ \ \ \ \ \ enum\ Mode\{\ None,\ Name,\ QuotedName,\ Tag,\ EscapedName\ \};\ \ \ \ \ \ \ \ Mode\ m\_mode\ =\ None;\ \ \ \ \ \ \ \ Mode\ lastMode\ =\ None;\ \ \ \ \ \ \ \ bool\ m\_exclusion\ =\ false;\ \ \ \ \ \ \ \ std::size\_t\ m\_pos\ =\ 0;\ \ \ \ \ \ \ \ std::size\_t\ m\_realPatternPos\ =\ 0;\ \ \ \ \ \ \ \ std::string\ m\_arg;\ \ \ \ \ \ \ \ std::string\ m\_substring;\ \ \ \ \ \ \ \ std::string\ m\_patternName;\ \ \ \ \ \ \ \ std::vector<std::size\_t>\ m\_escapeChars;\ \ \ \ \ \ \ \ TestSpec::Filter\ m\_currentFilter;\ \ \ \ \ \ \ \ TestSpec\ m\_testSpec;\ \ \ \ \ \ \ \ ITagAliasRegistry\ const*\ m\_tagAliases\ =\ nullptr;\ \ \ \ public:\ \ \ \ \ \ \ \ TestSpecParser(\ ITagAliasRegistry\ const\&\ tagAliases\ );\ \ \ \ \ \ \ \ TestSpecParser\&\ parse(\ std::string\ const\&\ arg\ );\ \ \ \ \ \ \ \ TestSpec\ testSpec();\ \ \ \ private:\ \ \ \ \ \ \ \ bool\ visitChar(\ char\ c\ );\ \ \ \ \ \ \ \ void\ startNewMode(\ Mode\ mode\ );\ \ \ \ \ \ \ \ bool\ processNoneChar(\ char\ c\ );\ \ \ \ \ \ \ \ void\ processNameChar(\ char\ c\ );\ \ \ \ \ \ \ \ bool\ processOtherChar(\ char\ c\ );\ \ \ \ \ \ \ \ void\ endMode();\ \ \ \ \ \ \ \ void\ escape();\ \ \ \ \ \ \ \ bool\ isControlChar(\ char\ c\ )\ const;\ \ \ \ \ \ \ \ void\ saveLastMode();\ \ \ \ \ \ \ \ void\ revertBackToLastMode();\ \ \ \ \ \ \ \ void\ addFilter();\ \ \ \ \ \ \ \ bool\ separate();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ preprocessPattern();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ addNamePattern();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ addTagPattern();\ \ \ \ \ \ \ \ inline\ void\ addCharToPattern(char\ c)\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_substring\ +=\ c;\ \ \ \ \ \ \ \ \ \ \ \ m\_patternName\ +=\ c;\ \ \ \ \ \ \ \ \ \ \ \ m\_realPatternPos++;\ \ \ \ \ \ \ \ \}\ \ \ \ \};\}\ \#ifdef\ \_\_clang\_\_\#pragma\ clang\ diagnostic\ pop\#endif\#endif\ \#ifndef\ CATCH\_TEXTFLOW\_HPP\_INCLUDED\#define\ CATCH\_TEXTFLOW\_HPP\_INCLUDED\#include\ <cassert>\#include\ <string>\#include\ <vector>namespace\ Catch\ \{\ \ \ \ namespace\ TextFlow\ \{\ \ \ \ \ \ \ \ class\ Columns;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ class\ AnsiSkippingString\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::string\ m\_string;\ \ \ \ \ \ \ \ \ \ \ \ std::size\_t\ m\_size\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ preprocessString();\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ class\ const\_iterator;\ \ \ \ \ \ \ \ \ \ \ \ using\ iterator\ =\ const\_iterator;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\ constexpr\ char\ sentinel\ =\ static\_cast<char>(\ 0xffu\ );\ \ \ \ \ \ \ \ \ \ \ \ explicit\ AnsiSkippingString(\ std::string\ const\&\ text\ );\ \ \ \ \ \ \ \ \ \ \ \ explicit\ AnsiSkippingString(\ std::string\&\&\ text\ );\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ begin()\ const;\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ end()\ const;\ \ \ \ \ \ \ \ \ \ \ \ size\_t\ size()\ const\ \{\ return\ m\_size;\ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ substring(\ const\_iterator\ begin,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ end\ )\ const;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ class\ AnsiSkippingString::const\_iterator\ \{\ \ \ \ \ \ \ \ \ \ \ \ friend\ AnsiSkippingString;\ \ \ \ \ \ \ \ \ \ \ \ struct\ EndTag\ \{\};\ \ \ \ \ \ \ \ \ \ \ \ const\ std::string*\ m\_string;\ \ \ \ \ \ \ \ \ \ \ \ std::string::const\_iterator\ m\_it;\ \ \ \ \ \ \ \ \ \ \ \ explicit\ const\_iterator(\ const\ std::string\&\ string,\ EndTag\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_string(\ \&string\ ),\ m\_it(\ string.end()\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ void\ tryParseAnsiEscapes();\ \ \ \ \ \ \ \ \ \ \ \ void\ advance();\ \ \ \ \ \ \ \ \ \ \ \ void\ unadvance();\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ using\ difference\_type\ =\ std::ptrdiff\_t;\ \ \ \ \ \ \ \ \ \ \ \ using\ value\_type\ =\ char;\ \ \ \ \ \ \ \ \ \ \ \ using\ pointer\ =\ value\_type*;\ \ \ \ \ \ \ \ \ \ \ \ using\ reference\ =\ value\_type\&;\ \ \ \ \ \ \ \ \ \ \ \ using\ iterator\_category\ =\ std::bidirectional\_iterator\_tag;\ \ \ \ \ \ \ \ \ \ \ \ explicit\ const\_iterator(\ const\ std::string\&\ string\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_string(\ \&string\ ),\ m\_it(\ string.begin()\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tryParseAnsiEscapes();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ char\ operator*()\ const\ \{\ return\ *m\_it;\ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\&\ operator++()\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ advance();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ operator++(\ int\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ iterator\ prev(\ *this\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ operator++();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ prev;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\&\ operator-\/-\/()\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unadvance();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ operator-\/-\/(\ int\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ iterator\ prev(\ *this\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ operator-\/-\/();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ prev;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ bool\ operator==(\ const\_iterator\ const\&\ other\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_it\ ==\ other.m\_it;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ bool\ operator!=(\ const\_iterator\ const\&\ other\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ !operator==(\ other\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ bool\ operator<=(\ const\_iterator\ const\&\ other\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_it\ <=\ other.m\_it;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ oneBefore()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ it\ =\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ -\/-\/it;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ class\ Column\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnsiSkippingString\ m\_string;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ m\_width\ =\ CATCH\_CONFIG\_CONSOLE\_WIDTH\ -\/\ 1;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ m\_indent\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ m\_initialIndent\ =\ std::string::npos;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ class\ const\_iterator\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ friend\ Column;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ struct\ EndTag\ \{\};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Column\ const\&\ m\_column;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnsiSkippingString::const\_iterator\ m\_lineStart;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnsiSkippingString::const\_iterator\ m\_lineEnd;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnsiSkippingString::const\_iterator\ m\_parsedTo;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ m\_addHyphen\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\_iterator(\ Column\ const\&\ column,\ EndTag\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_column(\ column\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_lineStart(\ m\_column.m\_string.end()\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_lineEnd(\ column.m\_string.end()\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_parsedTo(\ column.m\_string.end()\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ calcLength();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ indentSize()\ const;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ addIndentAndSuffix(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnsiSkippingString::const\_iterator\ start,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnsiSkippingString::const\_iterator\ end\ )\ const;\ \ \ \ \ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ difference\_type\ =\ std::ptrdiff\_t;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ value\_type\ =\ std::string;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ pointer\ =\ value\_type*;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ reference\ =\ value\_type\&;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ iterator\_category\ =\ std::forward\_iterator\_tag;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ explicit\ const\_iterator(\ Column\ const\&\ column\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ operator*()\ const;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\&\ operator++();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ operator++(\ int\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ operator==(\ const\_iterator\ const\&\ other\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_lineStart\ ==\ other.m\_lineStart\ \&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&m\_column\ ==\ \&other.m\_column;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ operator!=(\ const\_iterator\ const\&\ other\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ !operator==(\ other\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ using\ iterator\ =\ const\_iterator;\ \ \ \ \ \ \ \ \ \ \ \ explicit\ Column(\ std::string\ const\&\ text\ ):\ m\_string(\ text\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ explicit\ Column(\ std::string\&\&\ text\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_string(\ CATCH\_MOVE(\ text\ )\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ Column\&\ width(\ size\_t\ newWidth\ )\ \&\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(\ newWidth\ >\ 0\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_width\ =\ newWidth;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ Column\&\&\ width(\ size\_t\ newWidth\ )\ \&\&\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(\ newWidth\ >\ 0\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_width\ =\ newWidth;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(\ *this\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ Column\&\ indent(\ size\_t\ newIndent\ )\ \&\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_indent\ =\ newIndent;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ Column\&\&\ indent(\ size\_t\ newIndent\ )\ \&\&\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_indent\ =\ newIndent;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(\ *this\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ Column\&\ initialIndent(\ size\_t\ newIndent\ )\ \&\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_initialIndent\ =\ newIndent;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ Column\&\&\ initialIndent(\ size\_t\ newIndent\ )\ \&\&\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_initialIndent\ =\ newIndent;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(\ *this\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ size\_t\ width()\ const\ \{\ return\ m\_width;\ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ begin()\ const\ \{\ return\ const\_iterator(\ *this\ );\ \}\ \ \ \ \ \ \ \ \ \ \ \ const\_iterator\ end()\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ *this,\ const\_iterator::EndTag\{\}\ \};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator<<(\ std::ostream\&\ os,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Column\ const\&\ col\ );\ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns\ operator+(\ Column\ const\&\ lhs,\ Column\ const\&\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns\ operator+(\ Column\&\&\ lhs,\ Column\&\&\ rhs\ );\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Column\ Spacer(\ size\_t\ spaceWidth\ );\ \ \ \ \ \ \ \ class\ Columns\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::vector<Column>\ m\_columns;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ class\ iterator\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ struct\ EndTag\ \{\};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<Column>\ const\&\ m\_columns;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<Column::const\_iterator>\ m\_iterators;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ m\_activeIterators;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ iterator(\ Columns\ const\&\ columns,\ EndTag\ );\ \ \ \ \ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ difference\_type\ =\ std::ptrdiff\_t;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ value\_type\ =\ std::string;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ pointer\ =\ value\_type*;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ reference\ =\ value\_type\&;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ iterator\_category\ =\ std::forward\_iterator\_tag;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ explicit\ iterator(\ Columns\ const\&\ columns\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ operator==(\ iterator\ const\&\ other\ )\ const\ -\/>\ bool\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_iterators\ ==\ other.m\_iterators;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ operator!=(\ iterator\ const\&\ other\ )\ const\ -\/>\ bool\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_iterators\ !=\ other.m\_iterators;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ operator*()\ const;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ iterator\&\ operator++();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ iterator\ operator++(\ int\ );\ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ using\ const\_iterator\ =\ iterator;\ \ \ \ \ \ \ \ \ \ \ \ iterator\ begin()\ const\ \{\ return\ iterator(\ *this\ );\ \}\ \ \ \ \ \ \ \ \ \ \ \ iterator\ end()\ const\ \{\ return\ \{\ *this,\ iterator::EndTag()\ \};\ \}\ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns\&\ operator+=(\ Columns\&\ lhs,\ Column\ const\&\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns\&\ operator+=(\ Columns\&\ lhs,\ Column\&\&\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns\ operator+(\ Columns\ const\&\ lhs,\ Column\ const\&\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ friend\ Columns\ operator+(\ Columns\&\&\ lhs,\ Column\&\&\ rhs\ );\ \ \ \ \ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator<<(\ std::ostream\&\ os,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Columns\ const\&\ cols\ );\ \ \ \ \ \ \ \ \};\ \ \ \ \}\ \}\ \#endif\ \#ifndef\ CATCH\_TO\_STRING\_HPP\_INCLUDED\#define\ CATCH\_TO\_STRING\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\ \ \ \ template\ <typename\ T>\ \ \ \ std::string\ to\_string(T\ const\&\ t)\ \{\#if\ defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)\ \ \ \ \ \ \ \ return\ std::to\_string(t);\#else\ \ \ \ \ \ \ \ ReusableStringStream\ rss;\ \ \ \ \ \ \ \ rss\ <<\ t;\ \ \ \ \ \ \ \ return\ rss.str();\#endif\ \ \ \ \}\}\ \#endif\ \#ifndef\ CATCH\_UNCAUGHT\_EXCEPTIONS\_HPP\_INCLUDED\#define\ CATCH\_UNCAUGHT\_EXCEPTIONS\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ bool\ uncaught\_exceptions();\}\ \#endif\ \#ifndef\ CATCH\_XMLWRITER\_HPP\_INCLUDED\#define\ CATCH\_XMLWRITER\_HPP\_INCLUDED\#include\ <iosfwd>\#include\ <vector>\#include\ <cstdint>namespace\ Catch\ \{\ \ \ \ enum\ class\ XmlFormatting\ :\ std::uint8\_t\ \{\ \ \ \ \ \ \ \ None\ =\ 0x00,\ \ \ \ \ \ \ \ Indent\ =\ 0x01,\ \ \ \ \ \ \ \ Newline\ =\ 0x02,\ \ \ \ \};\ \ \ \ constexpr\ XmlFormatting\ operator|(\ XmlFormatting\ lhs,\ XmlFormatting\ rhs\ )\ \{\ \ \ \ \ \ \ \ return\ static\_cast<XmlFormatting>(\ static\_cast<std::uint8\_t>(\ lhs\ )\ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\_cast<std::uint8\_t>(\ rhs\ )\ );\ \ \ \ \}\ \ \ \ constexpr\ XmlFormatting\ operator\&(\ XmlFormatting\ lhs,\ XmlFormatting\ rhs\ )\ \{\ \ \ \ \ \ \ \ return\ static\_cast<XmlFormatting>(\ static\_cast<std::uint8\_t>(\ lhs\ )\ \&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\_cast<std::uint8\_t>(\ rhs\ )\ );\ \ \ \ \}\ \ \ \ \ \ \ \ class\ XmlEncode\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ enum\ ForWhat\ \{\ ForTextNodes,\ ForAttributes\ \};\ \ \ \ \ \ \ \ constexpr\ XmlEncode(\ StringRef\ str,\ ForWhat\ forWhat\ =\ ForTextNodes\ ):\ \ \ \ \ \ \ \ \ \ \ \ m\_str(\ str\ ),\ m\_forWhat(\ forWhat\ )\ \{\}\ \ \ \ \ \ \ \ void\ encodeTo(\ std::ostream\&\ os\ )\ const;\ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator\ <<\ (\ std::ostream\&\ os,\ XmlEncode\ const\&\ xmlEncode\ );\ \ \ \ private:\ \ \ \ \ \ \ \ StringRef\ m\_str;\ \ \ \ \ \ \ \ ForWhat\ m\_forWhat;\ \ \ \ \};\ \ \ \ class\ XmlWriter\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ class\ ScopedElement\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ ScopedElement(\ XmlWriter*\ writer,\ XmlFormatting\ fmt\ );\ \ \ \ \ \ \ \ \ \ \ \ ScopedElement(\ ScopedElement\&\&\ other\ )\ noexcept;\ \ \ \ \ \ \ \ \ \ \ \ ScopedElement\&\ operator=(\ ScopedElement\&\&\ other\ )\ noexcept;\ \ \ \ \ \ \ \ \ \ \ \ \string~ScopedElement();\ \ \ \ \ \ \ \ \ \ \ \ ScopedElement\&\ \ \ \ \ \ \ \ \ \ \ \ writeText(\ StringRef\ text,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting\ fmt\ =\ XmlFormatting::Newline\ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting::Indent\ );\ \ \ \ \ \ \ \ \ \ \ \ ScopedElement\&\ writeAttribute(\ StringRef\ name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StringRef\ attribute\ );\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ =\ typename\ std::enable\_if\_t<\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_convertible<T,\ StringRef>::value>>\ \ \ \ \ \ \ \ \ \ \ \ ScopedElement\&\ writeAttribute(\ StringRef\ name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\ const\&\ attribute\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_writer-\/>writeAttribute(\ name,\ attribute\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ private:\ \ \ \ \ \ \ \ \ \ \ \ XmlWriter*\ m\_writer\ =\ nullptr;\ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting\ m\_fmt;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ XmlWriter(\ std::ostream\&\ os\ );\ \ \ \ \ \ \ \ \string~XmlWriter();\ \ \ \ \ \ \ \ XmlWriter(\ XmlWriter\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ XmlWriter\&\ operator=(\ XmlWriter\ const\&\ )\ =\ delete;\ \ \ \ \ \ \ \ XmlWriter\&\ startElement(\ std::string\ const\&\ name,\ XmlFormatting\ fmt\ =\ XmlFormatting::Newline\ |\ XmlFormatting::Indent);\ \ \ \ \ \ \ \ ScopedElement\ scopedElement(\ std::string\ const\&\ name,\ XmlFormatting\ fmt\ =\ XmlFormatting::Newline\ |\ XmlFormatting::Indent);\ \ \ \ \ \ \ \ XmlWriter\&\ endElement(XmlFormatting\ fmt\ =\ XmlFormatting::Newline\ |\ XmlFormatting::Indent);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlWriter\&\ writeAttribute(\ StringRef\ name,\ StringRef\ attribute\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlWriter\&\ writeAttribute(\ StringRef\ name,\ bool\ attribute\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlWriter\&\ writeAttribute(\ StringRef\ name,\ char\ const*\ attribute\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ =\ typename\ std::enable\_if\_t<\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_convertible<T,\ StringRef>::value>>\ \ \ \ \ \ \ \ XmlWriter\&\ writeAttribute(\ StringRef\ name,\ T\ const\&\ attribute\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ ReusableStringStream\ rss;\ \ \ \ \ \ \ \ \ \ \ \ rss\ <<\ attribute;\ \ \ \ \ \ \ \ \ \ \ \ return\ writeAttribute(\ name,\ rss.str()\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlWriter\&\ writeText(\ StringRef\ text,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting\ fmt\ =\ XmlFormatting::Newline\ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting::Indent\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlWriter\&\ writeComment(\ StringRef\ text,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting\ fmt\ =\ XmlFormatting::Newline\ |\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ XmlFormatting::Indent\ );\ \ \ \ \ \ \ \ void\ writeStylesheetRef(\ StringRef\ url\ );\ \ \ \ \ \ \ \ void\ ensureTagClosed();\ \ \ \ private:\ \ \ \ \ \ \ \ void\ applyFormatting(XmlFormatting\ fmt);\ \ \ \ \ \ \ \ void\ writeDeclaration();\ \ \ \ \ \ \ \ void\ newlineIfNecessary();\ \ \ \ \ \ \ \ bool\ m\_tagIsOpen\ =\ false;\ \ \ \ \ \ \ \ bool\ m\_needsNewline\ =\ false;\ \ \ \ \ \ \ \ std::vector<std::string>\ m\_tags;\ \ \ \ \ \ \ \ std::string\ m\_indent;\ \ \ \ \ \ \ \ std::ostream\&\ m\_os;\ \ \ \ \};\}\#endif\ \#ifndef\ CATCH\_MATCHERS\_ALL\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_ALL\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_IMPL\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_IMPL\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\#ifdef\ \_\_clang\_\_\#\ \ \ \ pragma\ clang\ diagnostic\ push\#\ \ \ \ pragma\ clang\ diagnostic\ ignored\ "{}-\/Wsign-\/compare"{}\#\ \ \ \ pragma\ clang\ diagnostic\ ignored\ "{}-\/Wnon-\/virtual-\/dtor"{}\#elif\ defined\ \_\_GNUC\_\_\#\ \ \ \ pragma\ GCC\ diagnostic\ push\#\ \ \ \ pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wsign-\/compare"{}\#\ \ \ \ pragma\ GCC\ diagnostic\ ignored\ "{}-\/Wnon-\/virtual-\/dtor"{}\#endif\ \ \ \ template<typename\ ArgT,\ typename\ MatcherT>\ \ \ \ class\ MatchExpr\ :\ public\ ITransientExpression\ \{\ \ \ \ \ \ \ \ ArgT\ \&\&\ m\_arg;\ \ \ \ \ \ \ \ MatcherT\ const\&\ m\_matcher;\ \ \ \ public:\ \ \ \ \ \ \ \ constexpr\ MatchExpr(\ ArgT\ \&\&\ arg,\ MatcherT\ const\&\ matcher\ )\ \ \ \ \ \ \ \ :\ \ \ ITransientExpression\{\ true,\ matcher.match(\ arg\ )\ \},\ \ \ \ \ \ \ \ \ \ \ \ \ m\_arg(\ CATCH\_FORWARD(arg)\ ),\ \ \ \ \ \ \ \ \ \ \ \ m\_matcher(\ matcher\ )\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ void\ streamReconstructedExpression(\ std::ostream\&\ os\ )\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ os\ <<\ Catch::Detail::stringify(\ m\_arg\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ '\ '\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ m\_matcher.toString();\ \ \ \ \ \ \ \ \}\ \ \ \ \};\#ifdef\ \_\_clang\_\_\#\ \ \ \ pragma\ clang\ diagnostic\ pop\#elif\ defined\ \_\_GNUC\_\_\#\ \ \ \ pragma\ GCC\ diagnostic\ pop\#endif\ \ \ \ namespace\ Matchers\ \{\ \ \ \ \ \ \ \ template\ <typename\ ArgT>\ \ \ \ \ \ \ \ class\ MatcherBase;\ \ \ \ \}\ \ \ \ using\ StringMatcher\ =\ Matchers::MatcherBase<std::string>;\ \ \ \ void\ handleExceptionMatchExpr(\ AssertionHandler\&\ handler,\ StringMatcher\ const\&\ matcher\ );\ \ \ \ template<typename\ ArgT,\ typename\ MatcherT>\ \ \ \ constexpr\ MatchExpr<ArgT,\ MatcherT>\ \ \ \ makeMatchExpr(\ ArgT\&\&\ arg,\ MatcherT\ const\&\ matcher\ )\ \{\ \ \ \ \ \ \ \ return\ MatchExpr<ArgT,\ MatcherT>(\ CATCH\_FORWARD(arg),\ matcher\ );\ \ \ \ \}\}\ \#define\ INTERNAL\_CHECK\_THAT(\ macroName,\ matcher,\ resultDisposition,\ arg\ )\ \(\backslash\)\ \ \ \ do\ \{\ \(\backslash\)\ \ \ \ \ \ \ \ Catch::AssertionHandler\ catchAssertionHandler(\ macroName\#\#\_catch\_sr,\ CATCH\_INTERNAL\_LINEINFO,\ CATCH\_INTERNAL\_STRINGIFY(arg)\ "{},\ "{}\ CATCH\_INTERNAL\_STRINGIFY(matcher),\ resultDisposition\ );\ \(\backslash\)\ \ \ \ \ \ \ \ INTERNAL\_CATCH\_TRY\ \{\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ catchAssertionHandler.handleExpr(\ Catch::makeMatchExpr(\ arg,\ matcher\ )\ );\ \(\backslash\)\ \ \ \ \ \ \ \ \}\ INTERNAL\_CATCH\_CATCH(\ catchAssertionHandler\ )\ \(\backslash\)\ \ \ \ \ \ \ \ catchAssertionHandler.complete();\ \(\backslash\)\ \ \ \ \}\ while(\ false\ )\#define\ INTERNAL\_CATCH\_THROWS\_MATCHES(\ macroName,\ exceptionType,\ resultDisposition,\ matcher,\ ...\ )\ \(\backslash\)\ \ \ \ do\ \{\ \(\backslash\)\ \ \ \ \ \ \ \ Catch::AssertionHandler\ catchAssertionHandler(\ macroName\#\#\_catch\_sr,\ CATCH\_INTERNAL\_LINEINFO,\ CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_)\ "{},\ "{}\ CATCH\_INTERNAL\_STRINGIFY(exceptionType)\ "{},\ "{}\ CATCH\_INTERNAL\_STRINGIFY(matcher),\ resultDisposition\ );\ \(\backslash\)\ \ \ \ \ \ \ \ if(\ catchAssertionHandler.allowThrows()\ )\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ try\ \{\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CATCH\_INTERNAL\_SUPPRESS\_USELESS\_CAST\_WARNINGS\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\_cast<void>(\_\_VA\_ARGS\_\_\ );\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ catchAssertionHandler.handleUnexpectedExceptionNotThrown();\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \}\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ catch(\ exceptionType\ const\&\ ex\ )\ \{\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ catchAssertionHandler.handleExpr(\ Catch::makeMatchExpr(\ ex,\ matcher\ )\ );\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \}\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ catch(\ ...\ )\ \{\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ catchAssertionHandler.handleUnexpectedInflightException();\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \}\ \(\backslash\)\ \ \ \ \ \ \ \ else\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ catchAssertionHandler.handleThrowingCallSkipped();\ \(\backslash\)\ \ \ \ \ \ \ \ catchAssertionHandler.complete();\ \(\backslash\)\ \ \ \ \}\ while(\ false\ )\#endif\ \#include\ <string>\#include\ <vector>namespace\ Catch\ \{namespace\ Matchers\ \{\ \ \ \ class\ MatcherUntypedBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ MatcherUntypedBase()\ =\ default;\ \ \ \ \ \ \ \ MatcherUntypedBase(MatcherUntypedBase\ const\&)\ =\ default;\ \ \ \ \ \ \ \ MatcherUntypedBase(MatcherUntypedBase\&\&)\ =\ default;\ \ \ \ \ \ \ \ MatcherUntypedBase\&\ operator\ =\ (MatcherUntypedBase\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ MatcherUntypedBase\&\ operator\ =\ (MatcherUntypedBase\&\&)\ =\ delete;\ \ \ \ \ \ \ \ std::string\ toString()\ const;\ \ \ \ protected:\ \ \ \ \ \ \ \ virtual\ \string~MatcherUntypedBase();\ \ \ \ \ \ \ \ \ virtual\ std::string\ describe()\ const\ =\ 0;\ \ \ \ \ \ \ \ mutable\ std::string\ m\_cachedToString;\ \ \ \ \};\ \ \ \ template<typename\ T>\ \ \ \ class\ MatcherBase\ :\ public\ MatcherUntypedBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ virtual\ bool\ match(\ T\ const\&\ arg\ )\ const\ =\ 0;\ \ \ \ \};\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ class\ MatchAllOf\ final\ :\ public\ MatcherBase<ArgT>\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::vector<MatcherBase<ArgT>\ const*>\ m\_matchers;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOf()\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOf(MatchAllOf\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOf\&\ operator=(MatchAllOf\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOf(MatchAllOf\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOf\&\ operator=(MatchAllOf\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(\ ArgT\ const\&\ arg\ )\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(\ auto\ matcher\ :\ m\_matchers\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (!matcher-\/>match(arg))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description.reserve(\ 4\ +\ m\_matchers.size()*32\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ "{}(\ "{};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ first\ =\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(\ auto\ matcher\ :\ m\_matchers\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(\ first\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ first\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ "{}\ and\ "{};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ matcher-\/>toString();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ "{}\ )"{};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ description;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ friend\ MatchAllOf\ operator\&\&\ (MatchAllOf\&\&\ lhs,\ MatcherBase<ArgT>\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs.m\_matchers.push\_back(\&rhs);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(lhs);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ friend\ MatchAllOf\ operator\&\&\ (MatcherBase<ArgT>\ const\&\ lhs,\ MatchAllOf\&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rhs.m\_matchers.insert(rhs.m\_matchers.begin(),\ \&lhs);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(rhs);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ MatchAllOf<ArgT>\ operator\&\&\ (MatchAllOf<ArgT>\ const\&\ lhs,\ MatcherBase<ArgT>\ const\&\ rhs)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ MatchAllOf<ArgT>\ operator\&\&\ (MatcherBase<ArgT>\ const\&\ lhs,\ MatchAllOf<ArgT>\ const\&\ rhs)\ =\ delete;\ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ class\ MatchAnyOf\ final\ :\ public\ MatcherBase<ArgT>\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::vector<MatcherBase<ArgT>\ const*>\ m\_matchers;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOf()\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOf(MatchAnyOf\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOf\&\ operator=(MatchAnyOf\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOf(MatchAnyOf\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOf\&\ operator=(MatchAnyOf\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(\ ArgT\ const\&\ arg\ )\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(\ auto\ matcher\ :\ m\_matchers\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (matcher-\/>match(arg))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description.reserve(\ 4\ +\ m\_matchers.size()*32\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ "{}(\ "{};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ first\ =\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(\ auto\ matcher\ :\ m\_matchers\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(\ first\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ first\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ "{}\ or\ "{};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ matcher-\/>toString();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ description\ +=\ "{}\ )"{};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ description;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ friend\ MatchAnyOf\ operator||\ (MatchAnyOf\&\&\ lhs,\ MatcherBase<ArgT>\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs.m\_matchers.push\_back(\&rhs);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(lhs);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ friend\ MatchAnyOf\ operator||\ (MatcherBase<ArgT>\ const\&\ lhs,\ MatchAnyOf\&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rhs.m\_matchers.insert(rhs.m\_matchers.begin(),\ \&lhs);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ CATCH\_MOVE(rhs);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ MatchAnyOf<ArgT>\ operator||\ (MatchAnyOf<ArgT>\ const\&\ lhs,\ MatcherBase<ArgT>\ const\&\ rhs)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ MatchAnyOf<ArgT>\ operator||\ (MatcherBase<ArgT>\ const\&\ lhs,\ MatchAnyOf<ArgT>\ const\&\ rhs)\ =\ delete;\ \ \ \ \ \ \ \ template<typename\ ArgT>\ \ \ \ \ \ \ \ class\ MatchNotOf\ final\ :\ public\ MatcherBase<ArgT>\ \{\ \ \ \ \ \ \ \ \ \ \ \ MatcherBase<ArgT>\ const\&\ m\_underlyingMatcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ explicit\ MatchNotOf(\ MatcherBase<ArgT>\ const\&\ underlyingMatcher\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_underlyingMatcher(\ underlyingMatcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(\ ArgT\ const\&\ arg\ )\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ !m\_underlyingMatcher.match(\ arg\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}not\ "{}\ +\ m\_underlyingMatcher.toString();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \}\ \ \ \ \ template\ <typename\ T>\ \ \ \ Detail::MatchAllOf<T>\ operator\&\&\ (MatcherBase<T>\ const\&\ lhs,\ MatcherBase<T>\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ Detail::MatchAllOf<T>\{\}\ \&\&\ lhs\ \&\&\ rhs;\ \ \ \ \}\ \ \ \ template\ <typename\ T>\ \ \ \ Detail::MatchAnyOf<T>\ operator||\ (MatcherBase<T>\ const\&\ lhs,\ MatcherBase<T>\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ Detail::MatchAnyOf<T>\{\}\ ||\ lhs\ ||\ rhs;\ \ \ \ \}\ \ \ \ template\ <typename\ T>\ \ \ \ Detail::MatchNotOf<T>\ operator!\ (MatcherBase<T>\ const\&\ matcher)\ \{\ \ \ \ \ \ \ \ return\ Detail::MatchNotOf<T>\{\ matcher\ \};\ \ \ \ \}\}\ \}\ \#if\ defined(CATCH\_CONFIG\_PREFIX\_ALL)\ \&\&\ !defined(CATCH\_CONFIG\_DISABLE)\ \ \#define\ CATCH\_REQUIRE\_THROWS\_WITH(\ expr,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_STR\_MATCHES(\ "{}CATCH\_REQUIRE\_THROWS\_WITH"{},\ Catch::ResultDisposition::Normal,\ matcher,\ expr\ )\ \ \#define\ CATCH\_REQUIRE\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_MATCHES(\ "{}CATCH\_REQUIRE\_THROWS\_MATCHES"{},\ exceptionType,\ Catch::ResultDisposition::Normal,\ matcher,\ expr\ )\ \ \#define\ CATCH\_CHECK\_THROWS\_WITH(\ expr,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_STR\_MATCHES(\ "{}CATCH\_CHECK\_THROWS\_WITH"{},\ Catch::ResultDisposition::ContinueOnFailure,\ matcher,\ expr\ )\ \ \#define\ CATCH\_CHECK\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_MATCHES(\ "{}CATCH\_CHECK\_THROWS\_MATCHES"{},\ exceptionType,\ Catch::ResultDisposition::ContinueOnFailure,\ matcher,\ expr\ )\ \ \#define\ CATCH\_CHECK\_THAT(\ arg,\ matcher\ )\ INTERNAL\_CHECK\_THAT(\ "{}CATCH\_CHECK\_THAT"{},\ matcher,\ Catch::ResultDisposition::ContinueOnFailure,\ arg\ )\ \ \#define\ CATCH\_REQUIRE\_THAT(\ arg,\ matcher\ )\ INTERNAL\_CHECK\_THAT(\ "{}CATCH\_REQUIRE\_THAT"{},\ matcher,\ Catch::ResultDisposition::Normal,\ arg\ )\#elif\ defined(CATCH\_CONFIG\_PREFIX\_ALL)\ \&\&\ defined(CATCH\_CONFIG\_DISABLE)\ \ \#define\ CATCH\_REQUIRE\_THROWS\_WITH(\ expr,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\ \ \#define\ CATCH\_REQUIRE\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ (void)(0)\ \ \#define\ CATCH\_CHECK\_THROWS\_WITH(\ expr,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\ \ \#define\ CATCH\_CHECK\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ \ \ (void)(0)\ \ \#define\ CATCH\_CHECK\_THAT(\ arg,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\ \ \#define\ CATCH\_REQUIRE\_THAT(\ arg,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\#elif\ !defined(CATCH\_CONFIG\_PREFIX\_ALL)\ \&\&\ !defined(CATCH\_CONFIG\_DISABLE)\ \ \#define\ REQUIRE\_THROWS\_WITH(\ expr,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_STR\_MATCHES(\ "{}REQUIRE\_THROWS\_WITH"{},\ Catch::ResultDisposition::Normal,\ matcher,\ expr\ )\ \ \#define\ REQUIRE\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_MATCHES(\ "{}REQUIRE\_THROWS\_MATCHES"{},\ exceptionType,\ Catch::ResultDisposition::Normal,\ matcher,\ expr\ )\ \ \#define\ CHECK\_THROWS\_WITH(\ expr,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_STR\_MATCHES(\ "{}CHECK\_THROWS\_WITH"{},\ Catch::ResultDisposition::ContinueOnFailure,\ matcher,\ expr\ )\ \ \#define\ CHECK\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ INTERNAL\_CATCH\_THROWS\_MATCHES(\ "{}CHECK\_THROWS\_MATCHES"{},\ exceptionType,\ Catch::ResultDisposition::ContinueOnFailure,\ matcher,\ expr\ )\ \ \#define\ CHECK\_THAT(\ arg,\ matcher\ )\ INTERNAL\_CHECK\_THAT(\ "{}CHECK\_THAT"{},\ matcher,\ Catch::ResultDisposition::ContinueOnFailure,\ arg\ )\ \ \#define\ REQUIRE\_THAT(\ arg,\ matcher\ )\ INTERNAL\_CHECK\_THAT(\ "{}REQUIRE\_THAT"{},\ matcher,\ Catch::ResultDisposition::Normal,\ arg\ )\#elif\ !defined(CATCH\_CONFIG\_PREFIX\_ALL)\ \&\&\ defined(CATCH\_CONFIG\_DISABLE)\ \ \#define\ REQUIRE\_THROWS\_WITH(\ expr,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\ \ \#define\ REQUIRE\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ (void)(0)\ \ \#define\ CHECK\_THROWS\_WITH(\ expr,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\ \ \#define\ CHECK\_THROWS\_MATCHES(\ expr,\ exceptionType,\ matcher\ )\ \ \ (void)(0)\ \ \#define\ CHECK\_THAT(\ arg,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\ \ \#define\ REQUIRE\_THAT(\ arg,\ matcher\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (void)(0)\#endif\ \#endif\ \#ifndef\ CATCH\_MATCHERS\_CONTAINER\_PROPERTIES\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_CONTAINER\_PROPERTIES\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_TEMPLATED\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_TEMPLATED\_HPP\_INCLUDED\#include\ <array>\#include\ <algorithm>\#include\ <string>\#include\ <type\_traits>namespace\ Catch\ \{namespace\ Matchers\ \{\ \ \ \ class\ MatcherGenericBase\ :\ public\ MatcherUntypedBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ MatcherGenericBase()\ =\ default;\ \ \ \ \ \ \ \ \string~MatcherGenericBase()\ override;\ \ \ \ \ \ \ \ \ MatcherGenericBase(MatcherGenericBase\ const\&)\ =\ default;\ \ \ \ \ \ \ \ MatcherGenericBase(MatcherGenericBase\&\&)\ =\ default;\ \ \ \ \ \ \ \ MatcherGenericBase\&\ operator=(MatcherGenericBase\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ MatcherGenericBase\&\ operator=(MatcherGenericBase\&\&)\ =\ delete;\ \ \ \ \};\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ template<std::size\_t\ N,\ std::size\_t\ M>\ \ \ \ \ \ \ \ std::array<void\ const*,\ N\ +\ M>\ array\_cat(std::array<void\ const*,\ N>\ \&\&\ lhs,\ std::array<void\ const*,\ M>\ \&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::array<void\ const*,\ N\ +\ M>\ arr\{\};\ \ \ \ \ \ \ \ \ \ \ \ std::copy\_n(lhs.begin(),\ N,\ arr.begin());\ \ \ \ \ \ \ \ \ \ \ \ std::copy\_n(rhs.begin(),\ M,\ arr.begin()\ +\ N);\ \ \ \ \ \ \ \ \ \ \ \ return\ arr;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<std::size\_t\ N>\ \ \ \ \ \ \ \ std::array<void\ const*,\ N+1>\ array\_cat(std::array<void\ const*,\ N>\ \&\&\ lhs,\ void\ const*\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::array<void\ const*,\ N+1>\ arr\{\};\ \ \ \ \ \ \ \ \ \ \ \ std::copy\_n(lhs.begin(),\ N,\ arr.begin());\ \ \ \ \ \ \ \ \ \ \ \ arr[N]\ =\ rhs;\ \ \ \ \ \ \ \ \ \ \ \ return\ arr;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<std::size\_t\ N>\ \ \ \ \ \ \ \ std::array<void\ const*,\ N+1>\ array\_cat(void\ const*\ lhs,\ std::array<void\ const*,\ N>\ \&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::array<void\ const*,\ N\ +\ 1>\ arr\{\ \{lhs\}\ \};\ \ \ \ \ \ \ \ \ \ \ \ std::copy\_n(rhs.begin(),\ N,\ arr.begin()\ +\ 1);\ \ \ \ \ \ \ \ \ \ \ \ return\ arr;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T>\ \ \ \ \ \ \ \ using\ is\_generic\_matcher\ =\ std::is\_base\_of<\ \ \ \ \ \ \ \ \ \ \ \ Catch::Matchers::MatcherGenericBase,\ \ \ \ \ \ \ \ \ \ \ \ std::remove\_cv\_t<std::remove\_reference\_t<T>>\ \ \ \ \ \ \ \ >;\ \ \ \ \ \ \ \ template<typename...\ Ts>\ \ \ \ \ \ \ \ using\ are\_generic\_matchers\ =\ Catch::Detail::conjunction<is\_generic\_matcher<Ts>...>;\ \ \ \ \ \ \ \ template<typename\ T>\ \ \ \ \ \ \ \ using\ is\_matcher\ =\ std::is\_base\_of<\ \ \ \ \ \ \ \ \ \ \ \ Catch::Matchers::MatcherUntypedBase,\ \ \ \ \ \ \ \ \ \ \ \ std::remove\_cv\_t<std::remove\_reference\_t<T>>\ \ \ \ \ \ \ \ >;\ \ \ \ \ \ \ \ template<std::size\_t\ N,\ typename\ Arg>\ \ \ \ \ \ \ \ bool\ match\_all\_of(Arg\&\&,\ std::array<void\ const*,\ N>\ const\&,\ std::index\_sequence<>)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T,\ typename...\ MatcherTs,\ std::size\_t\ N,\ typename\ Arg,\ std::size\_t\ Idx,\ std::size\_t...\ Indices>\ \ \ \ \ \ \ \ bool\ match\_all\_of(Arg\&\&\ arg,\ std::array<void\ const*,\ N>\ const\&\ matchers,\ std::index\_sequence<Idx,\ Indices...>)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ static\_cast<T\ const*>(matchers[Idx])-\/>match(arg)\ \&\&\ match\_all\_of<MatcherTs...>(arg,\ matchers,\ std::index\_sequence<Indices...>\{\});\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<std::size\_t\ N,\ typename\ Arg>\ \ \ \ \ \ \ \ bool\ match\_any\_of(Arg\&\&,\ std::array<void\ const*,\ N>\ const\&,\ std::index\_sequence<>)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T,\ typename...\ MatcherTs,\ std::size\_t\ N,\ typename\ Arg,\ std::size\_t\ Idx,\ std::size\_t...\ Indices>\ \ \ \ \ \ \ \ bool\ match\_any\_of(Arg\&\&\ arg,\ std::array<void\ const*,\ N>\ const\&\ matchers,\ std::index\_sequence<Idx,\ Indices...>)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ static\_cast<T\ const*>(matchers[Idx])-\/>match(arg)\ ||\ match\_any\_of<MatcherTs...>(arg,\ matchers,\ std::index\_sequence<Indices...>\{\});\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ describe\_multi\_matcher(StringRef\ combine,\ std::string\ const*\ descriptions\_begin,\ std::string\ const*\ descriptions\_end);\ \ \ \ \ \ \ \ template<typename...\ MatcherTs,\ std::size\_t...\ Idx>\ \ \ \ \ \ \ \ std::string\ describe\_multi\_matcher(StringRef\ combine,\ std::array<void\ const*,\ sizeof...(MatcherTs)>\ const\&\ matchers,\ std::index\_sequence<Idx...>)\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::array<std::string,\ sizeof...(MatcherTs)>\ descriptions\ \{\{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\_cast<MatcherTs\ const*>(matchers[Idx])-\/>toString()...\ \ \ \ \ \ \ \ \ \ \ \ \}\};\ \ \ \ \ \ \ \ \ \ \ \ return\ describe\_multi\_matcher(combine,\ descriptions.data(),\ descriptions.data()\ +\ descriptions.size());\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template<typename...\ MatcherTs>\ \ \ \ \ \ \ \ class\ MatchAllOfGeneric\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric(MatchAllOfGeneric\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric\&\ operator=(MatchAllOfGeneric\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric(MatchAllOfGeneric\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric\&\ operator=(MatchAllOfGeneric\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric(MatcherTs\ const\&...\ matchers)\ :\ m\_matchers\{\ \{std::addressof(matchers)...\}\ \}\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ explicit\ MatchAllOfGeneric(std::array<void\ const*,\ sizeof...(MatcherTs)>\ matchers)\ :\ m\_matchers\{matchers\}\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template<typename\ Arg>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(Arg\&\&\ arg)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ match\_all\_of<MatcherTs...>(arg,\ m\_matchers,\ std::index\_sequence\_for<MatcherTs...>\{\});\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ describe\_multi\_matcher<MatcherTs...>("{}\ and\ "{}\_sr,\ m\_matchers,\ std::index\_sequence\_for<MatcherTs...>\{\});\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::array<void\ const*,\ sizeof...(\ MatcherTs\ )>\ m\_matchers;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename...\ MatchersRHS>\ \ \ \ \ \ \ \ \ \ \ \ friend\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatcherTs...,\ MatchersRHS...>\ operator\ \&\&\ (\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatcherTs...>\&\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatchersRHS...>\&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ MatchAllOfGeneric<MatcherTs...,\ MatchersRHS...>\{array\_cat(CATCH\_MOVE(lhs.m\_matchers),\ CATCH\_MOVE(rhs.m\_matchers))\};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ MatcherRHS>\ \ \ \ \ \ \ \ \ \ \ \ friend\ std::enable\_if\_t<is\_matcher<MatcherRHS>::value,\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatcherTs...,\ MatcherRHS>>\ operator\ \&\&\ (\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatcherTs...>\&\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatcherRHS\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ MatchAllOfGeneric<MatcherTs...,\ MatcherRHS>\{array\_cat(CATCH\_MOVE(lhs.m\_matchers),\ static\_cast<void\ const*>(\&rhs))\};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ MatcherLHS>\ \ \ \ \ \ \ \ \ \ \ \ friend\ std::enable\_if\_t<is\_matcher<MatcherLHS>::value,\ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatcherLHS,\ MatcherTs...>>\ operator\ \&\&\ (\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatcherLHS\ const\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAllOfGeneric<MatcherTs...>\&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ MatchAllOfGeneric<MatcherLHS,\ MatcherTs...>\{array\_cat(static\_cast<void\ const*>(std::addressof(lhs)),\ CATCH\_MOVE(rhs.m\_matchers))\};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ template<typename...\ MatcherTs>\ \ \ \ \ \ \ \ class\ MatchAnyOfGeneric\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric(MatchAnyOfGeneric\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric\&\ operator=(MatchAnyOfGeneric\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric(MatchAnyOfGeneric\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric\&\ operator=(MatchAnyOfGeneric\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric(MatcherTs\ const\&...\ matchers)\ :\ m\_matchers\{\ \{std::addressof(matchers)...\}\ \}\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ explicit\ MatchAnyOfGeneric(std::array<void\ const*,\ sizeof...(MatcherTs)>\ matchers)\ :\ m\_matchers\{matchers\}\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template<typename\ Arg>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(Arg\&\&\ arg)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ match\_any\_of<MatcherTs...>(arg,\ m\_matchers,\ std::index\_sequence\_for<MatcherTs...>\{\});\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ describe\_multi\_matcher<MatcherTs...>("{}\ or\ "{}\_sr,\ m\_matchers,\ std::index\_sequence\_for<MatcherTs...>\{\});\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::array<void\ const*,\ sizeof...(\ MatcherTs\ )>\ m\_matchers;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename...\ MatchersRHS>\ \ \ \ \ \ \ \ \ \ \ \ friend\ MatchAnyOfGeneric<MatcherTs...,\ MatchersRHS...>\ operator\ ||\ (\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric<MatcherTs...>\&\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric<MatchersRHS...>\&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ MatchAnyOfGeneric<MatcherTs...,\ MatchersRHS...>\{array\_cat(CATCH\_MOVE(lhs.m\_matchers),\ CATCH\_MOVE(rhs.m\_matchers))\};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ MatcherRHS>\ \ \ \ \ \ \ \ \ \ \ \ friend\ std::enable\_if\_t<is\_matcher<MatcherRHS>::value,\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric<MatcherTs...,\ MatcherRHS>>\ operator\ ||\ (\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric<MatcherTs...>\&\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatcherRHS\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ MatchAnyOfGeneric<MatcherTs...,\ MatcherRHS>\{array\_cat(CATCH\_MOVE(lhs.m\_matchers),\ static\_cast<void\ const*>(std::addressof(rhs)))\};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template<typename\ MatcherLHS>\ \ \ \ \ \ \ \ \ \ \ \ friend\ std::enable\_if\_t<is\_matcher<MatcherLHS>::value,\ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric<MatcherLHS,\ MatcherTs...>>\ operator\ ||\ (\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatcherLHS\ const\&\ lhs,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchAnyOfGeneric<MatcherTs...>\&\&\ rhs)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ MatchAnyOfGeneric<MatcherLHS,\ MatcherTs...>\{array\_cat(static\_cast<void\ const*>(std::addressof(lhs)),\ CATCH\_MOVE(rhs.m\_matchers))\};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ template<typename\ MatcherT>\ \ \ \ \ \ \ \ class\ MatchNotOfGeneric\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ MatcherT\ const\&\ m\_matcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ MatchNotOfGeneric(MatchNotOfGeneric\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchNotOfGeneric\&\ operator=(MatchNotOfGeneric\ const\&)\ =\ delete;\ \ \ \ \ \ \ \ \ \ \ \ MatchNotOfGeneric(MatchNotOfGeneric\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ MatchNotOfGeneric\&\ operator=(MatchNotOfGeneric\&\&)\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ explicit\ MatchNotOfGeneric(MatcherT\ const\&\ matcher)\ :\ m\_matcher\{matcher\}\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template<typename\ Arg>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(Arg\&\&\ arg)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ !m\_matcher.match(arg);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}not\ "{}\ +\ m\_matcher.toString();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ friend\ MatcherT\ const\&\ operator\ !\ (MatchNotOfGeneric<MatcherT>\ const\&\ matcher)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ matcher.m\_matcher;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \}\ \ \ \ \ \ \ \ \ template<typename\ MatcherLHS,\ typename\ MatcherRHS>\ \ \ \ std::enable\_if\_t<Detail::are\_generic\_matchers<MatcherLHS,\ MatcherRHS>::value,\ Detail::MatchAllOfGeneric<MatcherLHS,\ MatcherRHS>>\ \ \ \ \ \ \ \ operator\ \&\&\ (MatcherLHS\ const\&\ lhs,\ MatcherRHS\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ \{\ lhs,\ rhs\ \};\ \ \ \ \}\ \ \ \ template<typename\ MatcherLHS,\ typename\ MatcherRHS>\ \ \ \ std::enable\_if\_t<Detail::are\_generic\_matchers<MatcherLHS,\ MatcherRHS>::value,\ Detail::MatchAnyOfGeneric<MatcherLHS,\ MatcherRHS>>\ \ \ \ \ \ \ \ operator\ ||\ (MatcherLHS\ const\&\ lhs,\ MatcherRHS\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ \{\ lhs,\ rhs\ \};\ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ MatcherT>\ \ \ \ std::enable\_if\_t<Detail::is\_generic\_matcher<MatcherT>::value,\ Detail::MatchNotOfGeneric<MatcherT>>\ \ \ \ \ \ \ \ operator\ !\ (MatcherT\ const\&\ matcher)\ \{\ \ \ \ \ \ \ \ return\ Detail::MatchNotOfGeneric<MatcherT>\{matcher\};\ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ MatcherLHS,\ typename\ ArgRHS>\ \ \ \ std::enable\_if\_t<Detail::is\_generic\_matcher<MatcherLHS>::value,\ Detail::MatchAllOfGeneric<MatcherLHS,\ MatcherBase<ArgRHS>>>\ \ \ \ \ \ \ \ operator\ \&\&\ (MatcherLHS\ const\&\ lhs,\ MatcherBase<ArgRHS>\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ \{\ lhs,\ rhs\ \};\ \ \ \ \}\ \ \ \ template<typename\ ArgLHS,\ typename\ MatcherRHS>\ \ \ \ std::enable\_if\_t<Detail::is\_generic\_matcher<MatcherRHS>::value,\ Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>,\ MatcherRHS>>\ \ \ \ \ \ \ \ operator\ \&\&\ (MatcherBase<ArgLHS>\ const\&\ lhs,\ MatcherRHS\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ \{\ lhs,\ rhs\ \};\ \ \ \ \}\ \ \ \ template<typename\ MatcherLHS,\ typename\ ArgRHS>\ \ \ \ std::enable\_if\_t<Detail::is\_generic\_matcher<MatcherLHS>::value,\ Detail::MatchAnyOfGeneric<MatcherLHS,\ MatcherBase<ArgRHS>>>\ \ \ \ \ \ \ \ operator\ ||\ (MatcherLHS\ const\&\ lhs,\ MatcherBase<ArgRHS>\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ \{\ lhs,\ rhs\ \};\ \ \ \ \}\ \ \ \ template<typename\ ArgLHS,\ typename\ MatcherRHS>\ \ \ \ std::enable\_if\_t<Detail::is\_generic\_matcher<MatcherRHS>::value,\ Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>,\ MatcherRHS>>\ \ \ \ \ \ \ \ operator\ ||\ (MatcherBase<ArgLHS>\ const\&\ lhs,\ MatcherRHS\ const\&\ rhs)\ \{\ \ \ \ \ \ \ \ return\ \{\ lhs,\ rhs\ \};\ \ \ \ \}\}\ \}\ \#endif\ namespace\ Catch\ \{\ \ \ \ namespace\ Matchers\ \{\ \ \ \ \ \ \ \ class\ IsEmptyMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\#if\ defined(CATCH\_CONFIG\_POLYFILL\_NONMEMBER\_CONTAINER\_ACCESS)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ Catch::Detail::empty;\#else\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ std::empty;\#endif\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ empty(rng);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ class\ HasSizeMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ std::size\_t\ m\_target\_size;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ explicit\ HasSizeMatcher(std::size\_t\ target\_size):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_target\_size(target\_size)\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\#if\ defined(CATCH\_CONFIG\_POLYFILL\_NONMEMBER\_CONTAINER\_ACCESS)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ Catch::Detail::size;\#else\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ std::size;\#endif\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ size(rng)\ ==\ m\_target\_size;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ class\ SizeMatchesMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ Matcher\ m\_matcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ explicit\ SizeMatchesMatcher(Matcher\ m):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_matcher(CATCH\_MOVE(m))\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\#if\ defined(CATCH\_CONFIG\_POLYFILL\_NONMEMBER\_CONTAINER\_ACCESS)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ Catch::Detail::size;\#else\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ std::size;\#endif\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_matcher.match(size(rng));\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}size\ matches\ "{}\ +\ m\_matcher.describe();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IsEmptyMatcher\ IsEmpty();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ HasSizeMatcher\ SizeIs(std::size\_t\ sz);\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ std::enable\_if\_t<Detail::is\_matcher<Matcher>::value,\ \ \ \ \ \ \ \ SizeMatchesMatcher<Matcher>>\ SizeIs(Matcher\&\&\ m)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ SizeMatchesMatcher<Matcher>\{CATCH\_FORWARD(m)\};\ \ \ \ \ \ \ \ \}\ \ \ \ \}\ \}\ \#endif\ \#ifndef\ CATCH\_MATCHERS\_CONTAINS\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_CONTAINS\_HPP\_INCLUDED\#include\ <algorithm>\#include\ <functional>namespace\ Catch\ \{\ \ \ \ namespace\ Matchers\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T,\ typename\ Equality>\ \ \ \ \ \ \ \ class\ ContainsElementMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ T\ m\_desired;\ \ \ \ \ \ \ \ \ \ \ \ Equality\ m\_eq;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T2,\ typename\ Equality2>\ \ \ \ \ \ \ \ \ \ \ \ ContainsElementMatcher(T2\&\&\ target,\ Equality2\&\&\ predicate):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_desired(CATCH\_FORWARD(target)),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_eq(CATCH\_FORWARD(predicate))\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}contains\ element\ "{}\ +\ Catch::Detail::stringify(m\_desired);\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(\ RangeLike\&\&\ rng\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (\ auto\&\&\ elem\ :\ rng\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ m\_eq(\ elem,\ m\_desired\ )\ )\ \{\ return\ true;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ class\ ContainsMatcherMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ Matcher\ m\_matcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ContainsMatcherMatcher(Matcher\ matcher):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_matcher(CATCH\_MOVE(matcher))\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_matcher.match(elem))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}contains\ element\ matching\ "{}\ +\ m\_matcher.describe();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T>\ \ \ \ \ \ \ \ std::enable\_if\_t<!Detail::is\_matcher<T>::value,\ \ \ \ \ \ \ \ ContainsElementMatcher<T,\ std::equal\_to<>>>\ Contains(T\&\&\ elem)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(elem),\ std::equal\_to<>\{\}\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ std::enable\_if\_t<Detail::is\_matcher<Matcher>::value,\ \ \ \ \ \ \ \ ContainsMatcherMatcher<Matcher>>\ Contains(Matcher\&\&\ matcher)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(matcher)\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ T,\ typename\ Equality>\ \ \ \ \ \ \ \ ContainsElementMatcher<T,\ Equality>\ Contains(T\&\&\ elem,\ Equality\&\&\ eq)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(elem),\ CATCH\_FORWARD(eq)\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \}\}\#endif\ \#ifndef\ CATCH\_MATCHERS\_EXCEPTION\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_EXCEPTION\_HPP\_INCLUDEDnamespace\ Catch\ \{namespace\ Matchers\ \{class\ ExceptionMessageMatcher\ final\ :\ public\ MatcherBase<std::exception>\ \{\ \ \ \ std::string\ m\_message;public:\ \ \ \ ExceptionMessageMatcher(std::string\ const\&\ message):\ \ \ \ \ \ \ \ m\_message(message)\ \ \ \ \{\}\ \ \ \ bool\ match(std::exception\ const\&\ ex)\ const\ override;\ \ \ \ std::string\ describe()\ const\ override;\};ExceptionMessageMatcher\ Message(std::string\ const\&\ message);template\ <typename\ StringMatcherType>class\ ExceptionMessageMatchesMatcher\ final\ \ \ \ :\ public\ MatcherBase<std::exception>\ \{\ \ \ \ StringMatcherType\ m\_matcher;public:\ \ \ \ ExceptionMessageMatchesMatcher(\ StringMatcherType\ matcher\ ):\ \ \ \ \ \ \ \ m\_matcher(\ CATCH\_MOVE(\ matcher\ )\ )\ \{\}\ \ \ \ bool\ match(\ std::exception\ const\&\ ex\ )\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_matcher.match(\ ex.what()\ );\ \ \ \ \}\ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ return\ "{}\ matches\ \(\backslash\)"{}"{}\ +\ m\_matcher.describe()\ +\ '"{}';\ \ \ \ \}\};template\ <typename\ StringMatcherType>ExceptionMessageMatchesMatcher<StringMatcherType>MessageMatches(\ StringMatcherType\&\&\ matcher\ )\ \{\ \ \ \ return\ \{\ CATCH\_FORWARD(\ matcher\ )\ \};\}\}\ //\ namespace\ Matchers\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_MATCHERS\_EXCEPTION\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_FLOATING\_POINT\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_FLOATING\_POINT\_HPP\_INCLUDEDnamespace\ Catch\ \{namespace\ Matchers\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ enum\ class\ FloatingPointKind\ :\ uint8\_t;\ \ \ \ \}\ \ \ \ class\ \ WithinAbsMatcher\ final\ :\ public\ MatcherBase<double>\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ WithinAbsMatcher(double\ target,\ double\ margin);\ \ \ \ \ \ \ \ bool\ match(double\ const\&\ matchee)\ const\ override;\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ double\ m\_target;\ \ \ \ \ \ \ \ double\ m\_margin;\ \ \ \ \};\ \ \ \ \ \ \ \ WithinAbsMatcher\ WithinAbs(\ double\ target,\ double\ margin\ );\ \ \ \ class\ WithinUlpsMatcher\ final\ :\ public\ MatcherBase<double>\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ WithinUlpsMatcher(\ double\ target,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ ulps,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::FloatingPointKind\ baseType\ );\ \ \ \ \ \ \ \ bool\ match(double\ const\&\ matchee)\ const\ override;\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ double\ m\_target;\ \ \ \ \ \ \ \ uint64\_t\ m\_ulps;\ \ \ \ \ \ \ \ Detail::FloatingPointKind\ m\_type;\ \ \ \ \};\ \ \ \ \ \ \ \ WithinUlpsMatcher\ WithinULP(double\ target,\ uint64\_t\ maxUlpDiff);\ \ \ \ \ \ \ \ WithinUlpsMatcher\ WithinULP(float\ target,\ uint64\_t\ maxUlpDiff);\ \ \ \ //\ Given\ IEEE-\/754\ format\ for\ floats\ and\ doubles,\ we\ can\ assume\ \ \ \ //\ that\ float\ -\/>\ double\ promotion\ is\ lossless.\ Given\ this,\ we\ can\ \ \ \ //\ assume\ that\ if\ we\ do\ the\ standard\ relative\ comparison\ of\ \ \ \ //\ |lhs\ -\/\ rhs|\ <=\ epsilon\ *\ max(fabs(lhs),\ fabs(rhs)),\ then\ we\ get\ \ \ \ //\ the\ same\ result\ if\ we\ do\ this\ for\ floats,\ as\ if\ we\ do\ this\ for\ \ \ \ //\ doubles\ that\ were\ promoted\ from\ floats.\ \ \ \ class\ WithinRelMatcher\ final\ :\ public\ MatcherBase<double>\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ WithinRelMatcher(\ double\ target,\ double\ epsilon\ );\ \ \ \ \ \ \ \ bool\ match(double\ const\&\ matchee)\ const\ override;\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ double\ m\_target;\ \ \ \ \ \ \ \ double\ m\_epsilon;\ \ \ \ \};\ \ \ \ \ \ \ \ WithinRelMatcher\ WithinRel(double\ target,\ double\ eps);\ \ \ \ \ \ \ \ WithinRelMatcher\ WithinRel(double\ target);\ \ \ \ \ \ \ \ WithinRelMatcher\ WithinRel(float\ target,\ float\ eps);\ \ \ \ \ \ \ \ WithinRelMatcher\ WithinRel(float\ target);\ \ \ \ class\ IsNaNMatcher\ final\ :\ public\ MatcherBase<double>\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ IsNaNMatcher()\ =\ default;\ \ \ \ \ \ \ \ bool\ match(\ double\ const\&\ matchee\ )\ const\ override;\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \};\ \ \ \ IsNaNMatcher\ IsNaN();\}\ //\ namespace\ Matchers\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_MATCHERS\_FLOATING\_POINT\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_PREDICATE\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_PREDICATE\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{namespace\ Matchers\ \{namespace\ Detail\ \{\ \ \ \ std::string\ finalizeDescription(const\ std::string\&\ desc);\}\ //\ namespace\ Detailtemplate\ <typename\ T,\ typename\ Predicate>class\ PredicateMatcher\ final\ :\ public\ MatcherBase<T>\ \{\ \ \ \ Predicate\ m\_predicate;\ \ \ \ std::string\ m\_description;public:\ \ \ \ PredicateMatcher(Predicate\&\&\ elem,\ std::string\ const\&\ descr)\ \ \ \ \ \ \ \ :m\_predicate(CATCH\_FORWARD(elem)),\ \ \ \ \ \ \ \ m\_description(Detail::finalizeDescription(descr))\ \ \ \ \{\}\ \ \ \ bool\ match(\ T\ const\&\ item\ )\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_predicate(item);\ \ \ \ \}\ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ return\ m\_description;\ \ \ \ \}\};\ \ \ \ /**\ \ \ \ \ *\ Creates\ a\ matcher\ that\ calls\ delegates\ \`{}match`\ to\ the\ provided\ predicate.\ \ \ \ \ *\ \ \ \ \ *\ The\ user\ has\ to\ explicitly\ specify\ the\ argument\ type\ to\ the\ matcher\ \ \ \ \ */\ \ \ \ template<typename\ T,\ typename\ Pred>\ \ \ \ PredicateMatcher<T,\ Pred>\ Predicate(Pred\&\&\ predicate,\ std::string\ const\&\ description\ =\ "{}"{})\ \{\ \ \ \ \ \ \ \ static\_assert(is\_callable<Pred(T)>::value,\ "{}Predicate\ not\ callable\ with\ argument\ T"{});\ \ \ \ \ \ \ \ static\_assert(std::is\_same<bool,\ FunctionReturnType<Pred,\ T>>::value,\ "{}Predicate\ does\ not\ return\ bool"{});\ \ \ \ \ \ \ \ return\ PredicateMatcher<T,\ Pred>(CATCH\_FORWARD(predicate),\ description);\ \ \ \ \}\}\ //\ namespace\ Matchers\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_MATCHERS\_PREDICATE\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_QUANTIFIERS\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_QUANTIFIERS\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ namespace\ Matchers\ \{\ \ \ \ \ \ \ \ //\ Matcher\ for\ checking\ that\ all\ elements\ in\ range\ matches\ a\ given\ matcher.\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ class\ AllMatchMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ Matcher\ m\_matcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ AllMatchMatcher(Matcher\ matcher):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_matcher(CATCH\_MOVE(matcher))\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}all\ match\ "{}\ +\ m\_matcher.describe();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (!m\_matcher.match(elem))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ //\ Matcher\ for\ checking\ that\ no\ element\ in\ range\ matches\ a\ given\ matcher.\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ class\ NoneMatchMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ Matcher\ m\_matcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ NoneMatchMatcher(Matcher\ matcher):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_matcher(CATCH\_MOVE(matcher))\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}none\ match\ "{}\ +\ m\_matcher.describe();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_matcher.match(elem))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ //\ Matcher\ for\ checking\ that\ at\ least\ one\ element\ in\ range\ matches\ a\ given\ matcher.\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ class\ AnyMatchMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ Matcher\ m\_matcher;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ AnyMatchMatcher(Matcher\ matcher):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_matcher(CATCH\_MOVE(matcher))\ \ \ \ \ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}any\ match\ "{}\ +\ m\_matcher.describe();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_matcher.match(elem))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ //\ Matcher\ for\ checking\ that\ all\ elements\ in\ range\ are\ true.\ \ \ \ \ \ \ \ class\ AllTrueMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (!elem)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ //\ Matcher\ for\ checking\ that\ no\ element\ in\ range\ is\ true.\ \ \ \ \ \ \ \ class\ NoneTrueMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (elem)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ //\ Matcher\ for\ checking\ that\ any\ element\ in\ range\ is\ true.\ \ \ \ \ \ \ \ class\ AnyTrueMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(RangeLike\&\&\ rng)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\&\&\ elem\ :\ rng)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (elem)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ //\ Creates\ a\ matcher\ that\ checks\ whether\ all\ elements\ in\ a\ range\ match\ a\ matcher\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ AllMatchMatcher<Matcher>\ AllMatch(Matcher\&\&\ matcher)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(matcher)\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ //\ Creates\ a\ matcher\ that\ checks\ whether\ no\ element\ in\ a\ range\ matches\ a\ matcher.\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ NoneMatchMatcher<Matcher>\ NoneMatch(Matcher\&\&\ matcher)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(matcher)\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ //\ Creates\ a\ matcher\ that\ checks\ whether\ any\ element\ in\ a\ range\ matches\ a\ matcher.\ \ \ \ \ \ \ \ template\ <typename\ Matcher>\ \ \ \ \ \ \ \ AnyMatchMatcher<Matcher>\ AnyMatch(Matcher\&\&\ matcher)\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(matcher)\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ //\ Creates\ a\ matcher\ that\ checks\ whether\ all\ elements\ in\ a\ range\ are\ true\ \ \ \ \ \ \ \ AllTrueMatcher\ AllTrue();\ \ \ \ \ \ \ \ //\ Creates\ a\ matcher\ that\ checks\ whether\ no\ element\ in\ a\ range\ is\ true\ \ \ \ \ \ \ \ NoneTrueMatcher\ NoneTrue();\ \ \ \ \ \ \ \ //\ Creates\ a\ matcher\ that\ checks\ whether\ any\ element\ in\ a\ range\ is\ true\ \ \ \ \ \ \ \ AnyTrueMatcher\ AnyTrue();\ \ \ \ \}\}\#endif\ //\ CATCH\_MATCHERS\_QUANTIFIERS\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_RANGE\_EQUALS\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_RANGE\_EQUALS\_HPP\_INCLUDED\#include\ <algorithm>\#include\ <utility>namespace\ Catch\ \{\ \ \ \ namespace\ Matchers\ \{\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Matcher\ for\ checking\ that\ an\ element\ contains\ the\ same\ \ \ \ \ \ \ \ \ *\ elements\ in\ the\ same\ order\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ template\ <typename\ TargetRangeLike,\ typename\ Equality>\ \ \ \ \ \ \ \ class\ RangeEqualsMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ TargetRangeLike\ m\_desired;\ \ \ \ \ \ \ \ \ \ \ \ Equality\ m\_predicate;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ TargetRangeLike2,\ typename\ Equality2>\ \ \ \ \ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ \ \ \ \ RangeEqualsMatcher(\ TargetRangeLike2\&\&\ range,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Equality2\&\&\ predicate\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_desired(\ CATCH\_FORWARD(\ range\ )\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_predicate(\ CATCH\_FORWARD(\ predicate\ )\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(\ RangeLike\&\&\ rng\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ rng\_start\ =\ begin(\ rng\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ rng\_end\ =\ end(\ rng\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ target\_start\ =\ begin(\ m\_desired\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ target\_end\ =\ end(\ m\_desired\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ while\ (rng\_start\ !=\ rng\_end\ \&\&\ target\_start\ !=\ target\_end)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (!m\_predicate(*rng\_start,\ *target\_start))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++rng\_start;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++target\_start;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ rng\_start\ ==\ rng\_end\ \&\&\ target\_start\ ==\ target\_end;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}elements\ are\ "{}\ +\ Catch::Detail::stringify(\ m\_desired\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Matcher\ for\ checking\ that\ an\ element\ contains\ the\ same\ \ \ \ \ \ \ \ \ *\ elements\ (but\ not\ necessarily\ in\ the\ same\ order)\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ template\ <typename\ TargetRangeLike,\ typename\ Equality>\ \ \ \ \ \ \ \ class\ UnorderedRangeEqualsMatcher\ final\ :\ public\ MatcherGenericBase\ \{\ \ \ \ \ \ \ \ \ \ \ \ TargetRangeLike\ m\_desired;\ \ \ \ \ \ \ \ \ \ \ \ Equality\ m\_predicate;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ TargetRangeLike2,\ typename\ Equality2>\ \ \ \ \ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ \ \ \ \ UnorderedRangeEqualsMatcher(\ TargetRangeLike2\&\&\ range,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Equality2\&\&\ predicate\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_desired(\ CATCH\_FORWARD(\ range\ )\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_predicate(\ CATCH\_FORWARD(\ predicate\ )\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ RangeLike>\ \ \ \ \ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ \ \ \ \ bool\ match(\ RangeLike\&\&\ rng\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ std::begin;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ using\ std::end;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ Catch::Detail::is\_permutation(\ begin(\ m\_desired\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ end(\ m\_desired\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ begin(\ rng\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ end(\ rng\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_predicate\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}unordered\ elements\ are\ "{}\ +\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::Catch::Detail::stringify(\ m\_desired\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Creates\ a\ matcher\ that\ checks\ if\ all\ elements\ in\ a\ range\ are\ equal\ \ \ \ \ \ \ \ \ *\ to\ all\ elements\ in\ another\ range.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Uses\ the\ provided\ predicate\ \`{}predicate`\ to\ do\ the\ comparisons\ \ \ \ \ \ \ \ \ *\ (defaulting\ to\ \`{}std::equal\_to`)\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ template\ <typename\ RangeLike,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Equality\ =\ decltype(\ std::equal\_to<>\{\}\ )>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ RangeEqualsMatcher<RangeLike,\ Equality>\ \ \ \ \ \ \ \ RangeEquals(\ RangeLike\&\&\ range,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Equality\&\&\ predicate\ =\ std::equal\_to<>\{\}\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(\ range\ ),\ CATCH\_FORWARD(\ predicate\ )\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Creates\ a\ matcher\ that\ checks\ if\ all\ elements\ in\ a\ range\ are\ equal\ \ \ \ \ \ \ \ \ *\ to\ all\ elements\ in\ an\ initializer\ list.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Uses\ the\ provided\ predicate\ \`{}predicate`\ to\ do\ the\ comparisons\ \ \ \ \ \ \ \ \ *\ (defaulting\ to\ \`{}std::equal\_to`)\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ template\ <typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Equality\ =\ decltype(\ std::equal\_to<>\{\}\ )>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ RangeEqualsMatcher<std::initializer\_list<T>,\ Equality>\ \ \ \ \ \ \ \ RangeEquals(\ std::initializer\_list<T>\ range,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Equality\&\&\ predicate\ =\ std::equal\_to<>\{\}\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ range,\ CATCH\_FORWARD(\ predicate\ )\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Creates\ a\ matcher\ that\ checks\ if\ all\ elements\ in\ a\ range\ are\ equal\ \ \ \ \ \ \ \ \ *\ to\ all\ elements\ in\ another\ range,\ in\ some\ permutation.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Uses\ the\ provided\ predicate\ \`{}predicate`\ to\ do\ the\ comparisons\ \ \ \ \ \ \ \ \ *\ (defaulting\ to\ \`{}std::equal\_to`)\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ template\ <typename\ RangeLike,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Equality\ =\ decltype(\ std::equal\_to<>\{\}\ )>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ UnorderedRangeEqualsMatcher<RangeLike,\ Equality>\ \ \ \ \ \ \ \ UnorderedRangeEquals(\ RangeLike\&\&\ range,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Equality\&\&\ predicate\ =\ std::equal\_to<>\{\}\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ CATCH\_FORWARD(\ range\ ),\ CATCH\_FORWARD(\ predicate\ )\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Creates\ a\ matcher\ that\ checks\ if\ all\ elements\ in\ a\ range\ are\ equal\ \ \ \ \ \ \ \ \ *\ to\ all\ elements\ in\ an\ initializer\ list,\ in\ some\ permutation.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Uses\ the\ provided\ predicate\ \`{}predicate`\ to\ do\ the\ comparisons\ \ \ \ \ \ \ \ \ *\ (defaulting\ to\ \`{}std::equal\_to`)\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ template\ <typename\ T,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ Equality\ =\ decltype(\ std::equal\_to<>\{\}\ )>\ \ \ \ \ \ \ \ constexpr\ \ \ \ \ \ \ \ UnorderedRangeEqualsMatcher<std::initializer\_list<T>,\ Equality>\ \ \ \ \ \ \ \ UnorderedRangeEquals(\ std::initializer\_list<T>\ range,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Equality\&\&\ predicate\ =\ std::equal\_to<>\{\}\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ range,\ CATCH\_FORWARD(\ predicate\ )\ \};\ \ \ \ \ \ \ \ \}\ \ \ \ \}\ //\ namespace\ Matchers\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_MATCHERS\_RANGE\_EQUALS\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_STRING\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_STRING\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{namespace\ Matchers\ \{\ \ \ \ struct\ CasedString\ \{\ \ \ \ \ \ \ \ CasedString(\ std::string\ const\&\ str,\ CaseSensitive\ caseSensitivity\ );\ \ \ \ \ \ \ \ std::string\ adjustString(\ std::string\ const\&\ str\ )\ const;\ \ \ \ \ \ \ \ StringRef\ caseSensitivitySuffix()\ const;\ \ \ \ \ \ \ \ CaseSensitive\ m\_caseSensitivity;\ \ \ \ \ \ \ \ std::string\ m\_str;\ \ \ \ \};\ \ \ \ class\ StringMatcherBase\ :\ public\ MatcherBase<std::string>\ \{\ \ \ \ protected:\ \ \ \ \ \ \ \ CasedString\ m\_comparator;\ \ \ \ \ \ \ \ StringRef\ m\_operation;\ \ \ \ public:\ \ \ \ \ \ \ \ StringMatcherBase(\ StringRef\ operation,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CasedString\ const\&\ comparator\ );\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \};\ \ \ \ class\ StringEqualsMatcher\ final\ :\ public\ StringMatcherBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ StringEqualsMatcher(\ CasedString\ const\&\ comparator\ );\ \ \ \ \ \ \ \ bool\ match(\ std::string\ const\&\ source\ )\ const\ override;\ \ \ \ \};\ \ \ \ class\ StringContainsMatcher\ final\ :\ public\ StringMatcherBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ StringContainsMatcher(\ CasedString\ const\&\ comparator\ );\ \ \ \ \ \ \ \ bool\ match(\ std::string\ const\&\ source\ )\ const\ override;\ \ \ \ \};\ \ \ \ class\ StartsWithMatcher\ final\ :\ public\ StringMatcherBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ StartsWithMatcher(\ CasedString\ const\&\ comparator\ );\ \ \ \ \ \ \ \ bool\ match(\ std::string\ const\&\ source\ )\ const\ override;\ \ \ \ \};\ \ \ \ class\ EndsWithMatcher\ final\ :\ public\ StringMatcherBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ EndsWithMatcher(\ CasedString\ const\&\ comparator\ );\ \ \ \ \ \ \ \ bool\ match(\ std::string\ const\&\ source\ )\ const\ override;\ \ \ \ \};\ \ \ \ class\ RegexMatcher\ final\ :\ public\ MatcherBase<std::string>\ \{\ \ \ \ \ \ \ \ std::string\ m\_regex;\ \ \ \ \ \ \ \ CaseSensitive\ m\_caseSensitivity;\ \ \ \ public:\ \ \ \ \ \ \ \ RegexMatcher(\ std::string\ regex,\ CaseSensitive\ caseSensitivity\ );\ \ \ \ \ \ \ \ bool\ match(\ std::string\ const\&\ matchee\ )\ const\ override;\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override;\ \ \ \ \};\ \ \ \ \ \ \ \ StringEqualsMatcher\ Equals(\ std::string\ const\&\ str,\ CaseSensitive\ caseSensitivity\ =\ CaseSensitive::Yes\ );\ \ \ \ \ \ \ \ StringContainsMatcher\ ContainsSubstring(\ std::string\ const\&\ str,\ CaseSensitive\ caseSensitivity\ =\ CaseSensitive::Yes\ );\ \ \ \ \ \ \ \ EndsWithMatcher\ EndsWith(\ std::string\ const\&\ str,\ CaseSensitive\ caseSensitivity\ =\ CaseSensitive::Yes\ );\ \ \ \ \ \ \ \ StartsWithMatcher\ StartsWith(\ std::string\ const\&\ str,\ CaseSensitive\ caseSensitivity\ =\ CaseSensitive::Yes\ );\ \ \ \ \ \ \ \ RegexMatcher\ Matches(\ std::string\ const\&\ regex,\ CaseSensitive\ caseSensitivity\ =\ CaseSensitive::Yes\ );\}\ //\ namespace\ Matchers\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_MATCHERS\_STRING\_HPP\_INCLUDED\#ifndef\ CATCH\_MATCHERS\_VECTOR\_HPP\_INCLUDED\#define\ CATCH\_MATCHERS\_VECTOR\_HPP\_INCLUDED\#include\ <algorithm>namespace\ Catch\ \{namespace\ Matchers\ \{\ \ \ \ template<typename\ T,\ typename\ Alloc>\ \ \ \ class\ VectorContainsElementMatcher\ final\ :\ public\ MatcherBase<std::vector<T,\ Alloc>>\ \{\ \ \ \ \ \ \ \ T\ const\&\ m\_comparator;\ \ \ \ public:\ \ \ \ \ \ \ \ VectorContainsElementMatcher(T\ const\&\ comparator):\ \ \ \ \ \ \ \ \ \ \ \ m\_comparator(comparator)\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ bool\ match(std::vector<T,\ Alloc>\ const\&\ v)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\ const\&\ el\ :\ v)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (el\ ==\ m\_comparator)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Contains:\ "{}\ +\ ::Catch::Detail::stringify(\ m\_comparator\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ template<typename\ T,\ typename\ AllocComp,\ typename\ AllocMatch>\ \ \ \ class\ ContainsMatcher\ final\ :\ public\ MatcherBase<std::vector<T,\ AllocMatch>>\ \{\ \ \ \ \ \ \ \ std::vector<T,\ AllocComp>\ const\&\ m\_comparator;\ \ \ \ public:\ \ \ \ \ \ \ \ ContainsMatcher(std::vector<T,\ AllocComp>\ const\&\ comparator):\ \ \ \ \ \ \ \ \ \ \ \ m\_comparator(\ comparator\ )\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ bool\ match(std::vector<T,\ AllocMatch>\ const\&\ v)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ //\ !TBD:\ see\ note\ in\ EqualsMatcher\ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_comparator.size()\ >\ v.size())\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\ const\&\ comparator\ :\ m\_comparator)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ present\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ el\ :\ v)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (el\ ==\ comparator)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ present\ =\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (!present)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Contains:\ "{}\ +\ ::Catch::Detail::stringify(\ m\_comparator\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ template<typename\ T,\ typename\ AllocComp,\ typename\ AllocMatch>\ \ \ \ class\ EqualsMatcher\ final\ :\ public\ MatcherBase<std::vector<T,\ AllocMatch>>\ \{\ \ \ \ \ \ \ \ std::vector<T,\ AllocComp>\ const\&\ m\_comparator;\ \ \ \ public:\ \ \ \ \ \ \ \ EqualsMatcher(std::vector<T,\ AllocComp>\ const\&\ comparator):\ \ \ \ \ \ \ \ \ \ \ \ m\_comparator(\ comparator\ )\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ bool\ match(std::vector<T,\ AllocMatch>\ const\&\ v)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ //\ !TBD:\ This\ currently\ works\ if\ all\ elements\ can\ be\ compared\ using\ !=\ \ \ \ \ \ \ \ \ \ \ \ //\ -\/\ a\ more\ general\ approach\ would\ be\ via\ a\ compare\ template\ that\ defaults\ \ \ \ \ \ \ \ \ \ \ \ //\ to\ using\ !=.\ but\ could\ be\ specialised\ for,\ e.g.\ std::vector<T>\ etc\ \ \ \ \ \ \ \ \ \ \ \ //\ -\/\ then\ just\ call\ that\ directly\ \ \ \ \ \ \ \ \ \ \ \ if\ (\ m\_comparator.size()\ !=\ v.size()\ )\ \{\ return\ false;\ \}\ \ \ \ \ \ \ \ \ \ \ \ for\ (\ std::size\_t\ i\ =\ 0;\ i\ <\ v.size();\ ++i\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (\ !(\ m\_comparator[i]\ ==\ v[i]\ )\ )\ \{\ return\ false;\ \}\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Equals:\ "{}\ +\ ::Catch::Detail::stringify(\ m\_comparator\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ template<typename\ T,\ typename\ AllocComp,\ typename\ AllocMatch>\ \ \ \ class\ ApproxMatcher\ final\ :\ public\ MatcherBase<std::vector<T,\ AllocMatch>>\ \{\ \ \ \ \ \ \ \ std::vector<T,\ AllocComp>\ const\&\ m\_comparator;\ \ \ \ \ \ \ \ mutable\ Catch::Approx\ approx\ =\ Catch::Approx::custom();\ \ \ \ public:\ \ \ \ \ \ \ \ ApproxMatcher(std::vector<T,\ AllocComp>\ const\&\ comparator):\ \ \ \ \ \ \ \ \ \ \ \ m\_comparator(\ comparator\ )\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ bool\ match(std::vector<T,\ AllocMatch>\ const\&\ v)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_comparator.size()\ !=\ v.size())\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ for\ (std::size\_t\ i\ =\ 0;\ i\ <\ v.size();\ ++i)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_comparator[i]\ !=\ approx(v[i]))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ return\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}is\ approx:\ "{}\ +\ ::Catch::Detail::stringify(\ m\_comparator\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ =\ std::enable\_if\_t<std::is\_constructible<double,\ T>::value>>\ \ \ \ \ \ \ \ ApproxMatcher\&\ epsilon(\ T\ const\&\ newEpsilon\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ approx.epsilon(static\_cast<double>(newEpsilon));\ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ =\ std::enable\_if\_t<std::is\_constructible<double,\ T>::value>>\ \ \ \ \ \ \ \ ApproxMatcher\&\ margin(\ T\ const\&\ newMargin\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ approx.margin(static\_cast<double>(newMargin));\ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ template\ <typename\ =\ std::enable\_if\_t<std::is\_constructible<double,\ T>::value>>\ \ \ \ \ \ \ \ ApproxMatcher\&\ scale(\ T\ const\&\ newScale\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ approx.scale(static\_cast<double>(newScale));\ \ \ \ \ \ \ \ \ \ \ \ return\ *this;\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ template<typename\ T,\ typename\ AllocComp,\ typename\ AllocMatch>\ \ \ \ class\ UnorderedEqualsMatcher\ final\ :\ public\ MatcherBase<std::vector<T,\ AllocMatch>>\ \{\ \ \ \ \ \ \ \ std::vector<T,\ AllocComp>\ const\&\ m\_target;\ \ \ \ public:\ \ \ \ \ \ \ \ UnorderedEqualsMatcher(std::vector<T,\ AllocComp>\ const\&\ target):\ \ \ \ \ \ \ \ \ \ \ \ m\_target(target)\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ bool\ match(std::vector<T,\ AllocMatch>\ const\&\ vec)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ if\ (m\_target.size()\ !=\ vec.size())\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ return\ std::is\_permutation(m\_target.begin(),\ m\_target.end(),\ vec.begin());\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ describe()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}UnorderedEquals:\ "{}\ +\ ::Catch::Detail::stringify(m\_target);\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ //\ The\ following\ functions\ create\ the\ actual\ matcher\ objects.\ \ \ \ //\ This\ allows\ the\ types\ to\ be\ inferred\ \ \ \ \ \ \ \ template<typename\ T,\ typename\ AllocComp\ =\ std::allocator<T>,\ typename\ AllocMatch\ =\ AllocComp>\ \ \ \ ContainsMatcher<T,\ AllocComp,\ AllocMatch>\ Contains(\ std::vector<T,\ AllocComp>\ const\&\ comparator\ )\ \{\ \ \ \ \ \ \ \ return\ ContainsMatcher<T,\ AllocComp,\ AllocMatch>(comparator);\ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T,\ typename\ Alloc\ =\ std::allocator<T>>\ \ \ \ VectorContainsElementMatcher<T,\ Alloc>\ VectorContains(\ T\ const\&\ comparator\ )\ \{\ \ \ \ \ \ \ \ return\ VectorContainsElementMatcher<T,\ Alloc>(comparator);\ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T,\ typename\ AllocComp\ =\ std::allocator<T>,\ typename\ AllocMatch\ =\ AllocComp>\ \ \ \ EqualsMatcher<T,\ AllocComp,\ AllocMatch>\ Equals(\ std::vector<T,\ AllocComp>\ const\&\ comparator\ )\ \{\ \ \ \ \ \ \ \ return\ EqualsMatcher<T,\ AllocComp,\ AllocMatch>(comparator);\ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T,\ typename\ AllocComp\ =\ std::allocator<T>,\ typename\ AllocMatch\ =\ AllocComp>\ \ \ \ ApproxMatcher<T,\ AllocComp,\ AllocMatch>\ Approx(\ std::vector<T,\ AllocComp>\ const\&\ comparator\ )\ \{\ \ \ \ \ \ \ \ return\ ApproxMatcher<T,\ AllocComp,\ AllocMatch>(comparator);\ \ \ \ \}\ \ \ \ \ \ \ \ template<typename\ T,\ typename\ AllocComp\ =\ std::allocator<T>,\ typename\ AllocMatch\ =\ AllocComp>\ \ \ \ UnorderedEqualsMatcher<T,\ AllocComp,\ AllocMatch>\ UnorderedEquals(std::vector<T,\ AllocComp>\ const\&\ target)\ \{\ \ \ \ \ \ \ \ return\ UnorderedEqualsMatcher<T,\ AllocComp,\ AllocMatch>(target);\ \ \ \ \}\}\ //\ namespace\ Matchers\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_MATCHERS\_VECTOR\_HPP\_INCLUDED\#endif\ //\ CATCH\_MATCHERS\_ALL\_HPP\_INCLUDED/**\ \(\backslash\)file\ *\ This\ is\ a\ convenience\ header\ for\ Catch2's\ Reporter\ support.\ It\ includes\ *\ **all**\ of\ Catch2\ headers\ related\ to\ reporters,\ including\ all\ reporters.\ *\ *\ Generally\ the\ Catch2\ users\ should\ use\ specific\ includes\ they\ need,\ *\ but\ this\ header\ can\ be\ used\ instead\ for\ ease-\/of-\/experimentation,\ or\ *\ just\ plain\ convenience,\ at\ the\ cost\ of\ (significantly)\ increased\ *\ compilation\ times.\ *\ *\ When\ a\ new\ header\ (reporter)\ is\ added\ to\ either\ the\ \`{}reporter`\ folder,\ *\ or\ to\ the\ corresponding\ internal\ subfolder,\ it\ should\ be\ added\ here.\ */\#ifndef\ CATCH\_REPORTERS\_ALL\_HPP\_INCLUDED\#define\ CATCH\_REPORTERS\_ALL\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_AUTOMAKE\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_AUTOMAKE\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_STREAMING\_BASE\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_STREAMING\_BASE\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_COMMON\_BASE\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_COMMON\_BASE\_HPP\_INCLUDED\#include\ <map>\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ ColourImpl;\ \ \ \ /**\ \ \ \ \ *\ This\ is\ the\ base\ class\ for\ all\ reporters.\ \ \ \ \ *\ \ \ \ \ *\ If\ are\ writing\ a\ reporter,\ you\ must\ derive\ from\ this\ type,\ or\ one\ \ \ \ \ *\ of\ the\ helper\ reporter\ bases\ that\ are\ derived\ from\ this\ type.\ \ \ \ \ *\ \ \ \ \ *\ ReporterBase\ centralizes\ handling\ of\ various\ common\ tasks\ in\ reporters,\ \ \ \ \ *\ like\ storing\ the\ right\ stream\ for\ the\ reporters\ to\ write\ to,\ and\ \ \ \ \ *\ providing\ the\ default\ implementation\ of\ the\ different\ listing\ events.\ \ \ \ \ */\ \ \ \ class\ ReporterBase\ :\ public\ IEventListener\ \{\ \ \ \ protected:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::unique\_ptr<IStream>\ m\_wrapped\_stream;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::ostream\&\ m\_stream;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::unique\_ptr<ColourImpl>\ m\_colour;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::map<std::string,\ std::string>\ m\_customOptions;\ \ \ \ public:\ \ \ \ \ \ \ \ ReporterBase(\ ReporterConfig\&\&\ config\ );\ \ \ \ \ \ \ \ \string~ReporterBase()\ override;\ //\ =\ default;\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Provides\ a\ simple\ default\ listing\ of\ reporters.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Should\ look\ roughly\ like\ the\ reporter\ listing\ in\ v2\ and\ earlier\ \ \ \ \ \ \ \ \ *\ versions\ of\ Catch2.\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ void\ listReporters(\ \ \ \ \ \ \ \ \ \ \ \ std::vector<ReporterDescription>\ const\&\ descriptions\ )\ override;\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Provides\ a\ simple\ default\ listing\ of\ listeners\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Looks\ similarly\ to\ listing\ of\ reporters,\ but\ with\ listener\ type\ \ \ \ \ \ \ \ \ *\ instead\ of\ reporter\ name.\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ void\ listListeners(\ \ \ \ \ \ \ \ \ \ \ \ std::vector<ListenerDescription>\ const\&\ descriptions\ )\ override;\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Provides\ a\ simple\ default\ listing\ of\ tests.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Should\ look\ roughly\ like\ the\ test\ listing\ in\ v2\ and\ earlier\ versions\ \ \ \ \ \ \ \ \ *\ of\ Catch2.\ Especially\ supports\ low-\/verbosity\ listing\ that\ mimics\ the\ \ \ \ \ \ \ \ \ *\ old\ \`{}-\/-\/list-\/test-\/names-\/only`\ output.\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ void\ listTests(\ std::vector<TestCaseHandle>\ const\&\ tests\ )\ override;\ \ \ \ \ \ \ \ /**\ \ \ \ \ \ \ \ \ *\ Provides\ a\ simple\ default\ listing\ of\ tags.\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ Should\ look\ roughly\ like\ the\ tag\ listing\ in\ v2\ and\ earlier\ versions\ \ \ \ \ \ \ \ \ *\ of\ Catch2.\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ void\ listTags(\ std::vector<TagInfo>\ const\&\ tags\ )\ override;\ \ \ \ \};\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_COMMON\_BASE\_HPP\_INCLUDED\#include\ <vector>namespace\ Catch\ \{\ \ \ \ class\ StreamingReporterBase\ :\ public\ ReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ //\ GCC5\ compat:\ we\ cannot\ use\ inherited\ constructor,\ because\ it\ \ \ \ \ \ \ \ //\ \ \ \ \ \ \ \ \ \ \ \ \ \ doesn't\ implement\ backport\ of\ P0136\ \ \ \ \ \ \ \ StreamingReporterBase(ReporterConfig\&\&\ \_config):\ \ \ \ \ \ \ \ \ \ \ \ ReporterBase(CATCH\_MOVE(\_config))\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \string~StreamingReporterBase()\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ fatalErrorEncountered(\ StringRef\ /*error*/\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ /*unmatchedSpec*/\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ reportInvalidTestSpec(\ StringRef\ /*invalidArgument*/\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ \_testRunInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseStarting(TestCaseInfo\ const\&\ \_testInfo)\ override\ \ \{\ \ \ \ \ \ \ \ \ \ \ \ currentTestCaseInfo\ =\ \&\_testInfo;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testCasePartialStarting(\ TestCaseInfo\ const\&,\ uint64\_t\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ sectionStarting(SectionInfo\ const\&\ \_sectionInfo)\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_sectionStack.push\_back(\_sectionInfo);\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ assertionStarting(\ AssertionInfo\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ assertionEnded(\ AssertionStats\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ sectionEnded(SectionStats\ const\&\ /*\ \_sectionStats\ */)\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_sectionStack.pop\_back();\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testCasePartialEnded(\ TestCaseStats\ const\&,\ uint64\_t\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ testCaseEnded(TestCaseStats\ const\&\ /*\ \_testCaseStats\ */)\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ currentTestCaseInfo\ =\ nullptr;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testRunEnded(\ TestRunStats\ const\&\ /*\ \_testRunStats\ */\ )\ override;\ \ \ \ \ \ \ \ void\ skipTest(TestCaseInfo\ const\&)\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ //\ Don't\ do\ anything\ with\ this\ by\ default.\ \ \ \ \ \ \ \ \ \ \ \ //\ It\ can\ optionally\ be\ overridden\ in\ the\ derived\ class.\ \ \ \ \ \ \ \ \}\ \ \ \ protected:\ \ \ \ \ \ \ \ TestRunInfo\ currentTestRunInfo\{\ "{}test\ run\ has\ not\ started\ yet"{}\_sr\ \};\ \ \ \ \ \ \ \ TestCaseInfo\ const*\ currentTestCaseInfo\ =\ nullptr;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<SectionInfo>\ m\_sectionStack;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_STREAMING\_BASE\_HPP\_INCLUDED\#include\ <string>namespace\ Catch\ \{\ \ \ \ class\ AutomakeReporter\ final\ :\ public\ StreamingReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ //\ GCC5\ compat:\ we\ cannot\ use\ inherited\ constructor,\ because\ it\ \ \ \ \ \ \ \ //\ \ \ \ \ \ \ \ \ \ \ \ \ \ doesn't\ implement\ backport\ of\ P0136\ \ \ \ \ \ \ \ AutomakeReporter(ReporterConfig\&\&\ \_config):\ \ \ \ \ \ \ \ \ \ \ \ StreamingReporterBase(CATCH\_MOVE(\_config))\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \string~AutomakeReporter()\ override;\ \ \ \ \ \ \ \ static\ std::string\ getDescription()\ \{\ \ \ \ \ \ \ \ \ \ \ \ using\ namespace\ std::string\_literals;\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Reports\ test\ results\ in\ the\ format\ of\ Automake\ .trs\ files"{}s;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testCaseEnded(TestCaseStats\ const\&\ \_testCaseStats)\ override;\ \ \ \ \ \ \ \ void\ skipTest(TestCaseInfo\ const\&\ testInfo)\ override;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_AUTOMAKE\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_COMPACT\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_COMPACT\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ class\ CompactReporter\ final\ :\ public\ StreamingReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ using\ StreamingReporterBase::StreamingReporterBase;\ \ \ \ \ \ \ \ \string~CompactReporter()\ override;\ \ \ \ \ \ \ \ static\ std::string\ getDescription();\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ unmatchedSpec\ )\ override;\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ \_testInfo\ )\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(AssertionStats\ const\&\ \_assertionStats)\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(SectionStats\ const\&\ \_sectionStats)\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(TestRunStats\ const\&\ \_testRunStats)\ override;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_COMPACT\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_CONSOLE\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_CONSOLE\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ //\ Fwd\ decls\ \ \ \ class\ TablePrinter;\ \ \ \ class\ ConsoleReporter\ final\ :\ public\ StreamingReporterBase\ \{\ \ \ \ \ \ \ \ Detail::unique\_ptr<TablePrinter>\ m\_tablePrinter;\ \ \ \ public:\ \ \ \ \ \ \ \ ConsoleReporter(ReporterConfig\&\&\ config);\ \ \ \ \ \ \ \ \string~ConsoleReporter()\ override;\ \ \ \ \ \ \ \ static\ std::string\ getDescription();\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ unmatchedSpec\ )\ override;\ \ \ \ \ \ \ \ void\ reportInvalidTestSpec(\ StringRef\ arg\ )\ override;\ \ \ \ \ \ \ \ void\ assertionStarting(AssertionInfo\ const\&)\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(AssertionStats\ const\&\ \_assertionStats)\ override;\ \ \ \ \ \ \ \ void\ sectionStarting(SectionInfo\ const\&\ \_sectionInfo)\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(SectionStats\ const\&\ \_sectionStats)\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ name\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkStarting(BenchmarkInfo\ const\&\ info)\ override;\ \ \ \ \ \ \ \ void\ benchmarkEnded(BenchmarkStats<>\ const\&\ stats)\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(TestCaseStats\ const\&\ \_testCaseStats)\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(TestRunStats\ const\&\ \_testRunStats)\ override;\ \ \ \ \ \ \ \ void\ testRunStarting(TestRunInfo\ const\&\ \_testRunInfo)\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ void\ lazyPrint();\ \ \ \ \ \ \ \ void\ lazyPrintWithoutClosingBenchmarkTable();\ \ \ \ \ \ \ \ void\ lazyPrintRunInfo();\ \ \ \ \ \ \ \ void\ printTestCaseAndSectionHeader();\ \ \ \ \ \ \ \ void\ printClosedHeader(std::string\ const\&\ \_name);\ \ \ \ \ \ \ \ void\ printOpenHeader(std::string\ const\&\ \_name);\ \ \ \ \ \ \ \ //\ if\ string\ has\ a\ :\ in\ first\ line\ will\ set\ indent\ to\ follow\ it\ on\ \ \ \ \ \ \ \ //\ subsequent\ lines\ \ \ \ \ \ \ \ void\ printHeaderString(std::string\ const\&\ \_string,\ std::size\_t\ indent\ =\ 0);\ \ \ \ \ \ \ \ void\ printTotalsDivider(Totals\ const\&\ totals);\ \ \ \ \ \ \ \ bool\ m\_headerPrinted\ =\ false;\ \ \ \ \ \ \ \ bool\ m\_testRunInfoPrinted\ =\ false;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_CONSOLE\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_CUMULATIVE\_BASE\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_CUMULATIVE\_BASE\_HPP\_INCLUDED\#include\ <string>\#include\ <vector>namespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ class\ AssertionOrBenchmarkResult\ \{\ \ \ \ \ \ \ \ \ \ \ \ //\ This\ should\ really\ be\ a\ variant,\ but\ this\ is\ much\ faster\ \ \ \ \ \ \ \ \ \ \ \ //\ to\ write\ and\ the\ data\ layout\ here\ is\ already\ terrible\ \ \ \ \ \ \ \ \ \ \ \ //\ enough\ that\ we\ do\ not\ have\ to\ care\ about\ the\ object\ size.\ \ \ \ \ \ \ \ \ \ \ \ Optional<AssertionStats>\ m\_assertion;\ \ \ \ \ \ \ \ \ \ \ \ Optional<BenchmarkStats<>>\ m\_benchmark;\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ AssertionOrBenchmarkResult(AssertionStats\ const\&\ assertion);\ \ \ \ \ \ \ \ \ \ \ \ AssertionOrBenchmarkResult(BenchmarkStats<>\ const\&\ benchmark);\ \ \ \ \ \ \ \ \ \ \ \ bool\ isAssertion()\ const;\ \ \ \ \ \ \ \ \ \ \ \ bool\ isBenchmark()\ const;\ \ \ \ \ \ \ \ \ \ \ \ AssertionStats\ const\&\ asAssertion()\ const;\ \ \ \ \ \ \ \ \ \ \ \ BenchmarkStats<>\ const\&\ asBenchmark()\ const;\ \ \ \ \ \ \ \ \};\ \ \ \ \}\ \ \ \ /**\ \ \ \ \ *\ Utility\ base\ for\ reporters\ that\ need\ to\ handle\ all\ results\ at\ once\ \ \ \ \ *\ \ \ \ \ *\ It\ stores\ tree\ of\ all\ test\ cases,\ sections\ and\ assertions,\ and\ after\ the\ \ \ \ \ *\ test\ run\ is\ finished,\ calls\ into\ \`{}testRunEndedCumulative`\ to\ pass\ the\ \ \ \ \ *\ control\ to\ the\ deriving\ class.\ \ \ \ \ *\ \ \ \ \ *\ If\ you\ are\ deriving\ from\ this\ class\ and\ override\ any\ testing\ related\ \ \ \ \ *\ member\ functions,\ you\ should\ first\ call\ into\ the\ base's\ implementation\ to\ \ \ \ \ *\ avoid\ breaking\ the\ tree\ construction.\ \ \ \ \ *\ \ \ \ \ *\ Due\ to\ the\ way\ this\ base\ functions,\ it\ has\ to\ expand\ assertions\ up-\/front,\ \ \ \ \ *\ even\ if\ they\ are\ later\ unused\ (e.g.\ because\ the\ deriving\ reporter\ does\ \ \ \ \ *\ not\ report\ srtion\ expansion\ at\ all).\ Derived\ classes\ can\ use\ two\ \ \ \ \ *\ customization\ points,\ \`{}m\_shouldStoreSuccesfulAssertions`\ and\ \ \ \ \ *\ \`{}m\_shouldStoreFailedAssertions`,\ to\ disable\ the\ expansion\ and\ gain\ extra\ \ \ \ \ *\ performance.\ **Accessing\ the\ assertion\ expansions\ if\ it\ wasn't\ stored\ is\ \ \ \ \ *\ UB.**\ \ \ \ \ */\ \ \ \ class\ CumulativeReporterBase\ :\ public\ ReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ template<typename\ T,\ typename\ ChildNodeT>\ \ \ \ \ \ \ \ struct\ Node\ \{\ \ \ \ \ \ \ \ \ \ \ \ explicit\ Node(\ T\ const\&\ \_value\ )\ :\ value(\ \_value\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ using\ ChildNodes\ =\ std::vector<Detail::unique\_ptr<ChildNodeT>>;\ \ \ \ \ \ \ \ \ \ \ \ T\ value;\ \ \ \ \ \ \ \ \ \ \ \ ChildNodes\ children;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ struct\ SectionNode\ \{\ \ \ \ \ \ \ \ \ \ \ \ explicit\ SectionNode(SectionStats\ const\&\ \_stats)\ :\ stats(\_stats)\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ bool\ operator\ ==\ (SectionNode\ const\&\ other)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ stats.sectionInfo.lineInfo\ ==\ other.stats.sectionInfo.lineInfo;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ bool\ hasAnyAssertions()\ const;\ \ \ \ \ \ \ \ \ \ \ \ SectionStats\ stats;\ \ \ \ \ \ \ \ \ \ \ \ std::vector<Detail::unique\_ptr<SectionNode>>\ childSections;\ \ \ \ \ \ \ \ \ \ \ \ std::vector<Detail::AssertionOrBenchmarkResult>\ assertionsAndBenchmarks;\ \ \ \ \ \ \ \ \ \ \ \ std::string\ stdOut;\ \ \ \ \ \ \ \ \ \ \ \ std::string\ stdErr;\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ using\ TestCaseNode\ =\ Node<TestCaseStats,\ SectionNode>;\ \ \ \ \ \ \ \ using\ TestRunNode\ =\ Node<TestRunStats,\ TestCaseNode>;\ \ \ \ \ \ \ \ //\ GCC5\ compat:\ we\ cannot\ use\ inherited\ constructor,\ because\ it\ \ \ \ \ \ \ \ //\ \ \ \ \ \ \ \ \ \ \ \ \ \ doesn't\ implement\ backport\ of\ P0136\ \ \ \ \ \ \ \ CumulativeReporterBase(ReporterConfig\&\&\ \_config):\ \ \ \ \ \ \ \ \ \ \ \ ReporterBase(CATCH\_MOVE(\_config))\ \ \ \ \ \ \ \ \{\}\ \ \ \ \ \ \ \ \string~CumulativeReporterBase()\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ benchmarkStats\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ reportInvalidTestSpec(\ StringRef\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ fatalErrorEncountered(\ StringRef\ /*error*/\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ testCaseStarting(\ TestCaseInfo\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ testCasePartialStarting(\ TestCaseInfo\ const\&,\ uint64\_t\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ sectionStarting(\ SectionInfo\ const\&\ sectionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ assertionStarting(\ AssertionInfo\ const\&\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ assertionEnded(\ AssertionStats\ const\&\ assertionStats\ )\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(\ SectionStats\ const\&\ sectionStats\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialEnded(\ TestCaseStats\ const\&,\ uint64\_t\ )\ override\ \{\}\ \ \ \ \ \ \ \ void\ testCaseEnded(\ TestCaseStats\ const\&\ testCaseStats\ )\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(\ TestRunStats\ const\&\ testRunStats\ )\ override;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ virtual\ void\ testRunEndedCumulative()\ =\ 0;\ \ \ \ \ \ \ \ void\ skipTest(TestCaseInfo\ const\&)\ override\ \{\}\ \ \ \ protected:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ m\_shouldStoreSuccesfulAssertions\ =\ true;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ m\_shouldStoreFailedAssertions\ =\ true;\ \ \ \ \ \ \ \ //\ We\ need\ lazy\ construction\ here.\ We\ should\ probably\ refactor\ it\ \ \ \ \ \ \ \ //\ later,\ after\ the\ events\ are\ redone.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::unique\_ptr<TestRunNode>\ m\_testRun;\ \ \ \ private:\ \ \ \ \ \ \ \ //\ Note:\ We\ rely\ on\ pointer\ identity\ being\ stable,\ which\ is\ why\ \ \ \ \ \ \ \ //\ \ \ \ \ \ \ we\ store\ pointers\ to\ the\ nodes\ rather\ than\ the\ values.\ \ \ \ \ \ \ \ std::vector<Detail::unique\_ptr<TestCaseNode>>\ m\_testCases;\ \ \ \ \ \ \ \ //\ Root\ section\ of\ the\ \_current\_\ test\ case\ \ \ \ \ \ \ \ Detail::unique\_ptr<SectionNode>\ m\_rootSection;\ \ \ \ \ \ \ \ //\ Deepest\ section\ of\ the\ \_current\_\ test\ case\ \ \ \ \ \ \ \ SectionNode*\ m\_deepestSection\ =\ nullptr;\ \ \ \ \ \ \ \ //\ Stack\ of\ \_active\_\ sections\ in\ the\ \_current\_\ test\ case\ \ \ \ \ \ \ \ std::vector<SectionNode*>\ m\_sectionStack;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_CUMULATIVE\_BASE\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_EVENT\_LISTENER\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_EVENT\_LISTENER\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ /**\ \ \ \ \ *\ Base\ class\ to\ simplify\ implementing\ listeners.\ \ \ \ \ *\ \ \ \ \ *\ Provides\ empty\ default\ implementation\ for\ all\ IEventListener\ member\ \ \ \ \ *\ functions,\ so\ that\ a\ listener\ implementation\ can\ pick\ which\ \ \ \ \ *\ member\ functions\ it\ actually\ cares\ about.\ \ \ \ \ */\ \ \ \ class\ EventListenerBase\ :\ public\ IEventListener\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ using\ IEventListener::IEventListener;\ \ \ \ \ \ \ \ void\ reportInvalidTestSpec(\ StringRef\ unmatchedSpec\ )\ override;\ \ \ \ \ \ \ \ void\ fatalErrorEncountered(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ name\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ benchmarkInfo\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ benchmarkStats\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ assertionStarting(\ AssertionInfo\ const\&\ assertionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(\ AssertionStats\ const\&\ assertionStats\ )\ override;\ \ \ \ \ \ \ \ void\ listReporters(\ \ \ \ \ \ \ \ \ \ \ \ std::vector<ReporterDescription>\ const\&\ descriptions\ )\ override;\ \ \ \ \ \ \ \ void\ listListeners(\ \ \ \ \ \ \ \ \ \ \ \ std::vector<ListenerDescription>\ const\&\ descriptions\ )\ override;\ \ \ \ \ \ \ \ void\ listTests(\ std::vector<TestCaseHandle>\ const\&\ tests\ )\ override;\ \ \ \ \ \ \ \ void\ listTags(\ std::vector<TagInfo>\ const\&\ tagInfos\ )\ override;\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ unmatchedSpec\ )\ override;\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ testRunInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseStarting(\ TestCaseInfo\ const\&\ testInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialStarting(\ TestCaseInfo\ const\&\ testInfo,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ partNumber\ )\ override;\ \ \ \ \ \ \ \ void\ sectionStarting(\ SectionInfo\ const\&\ sectionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(\ SectionStats\ const\&\ sectionStats\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialEnded(\ TestCaseStats\ const\&\ testCaseStats,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ partNumber\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(\ TestCaseStats\ const\&\ testCaseStats\ )\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(\ TestRunStats\ const\&\ testRunStats\ )\ override;\ \ \ \ \ \ \ \ void\ skipTest(\ TestCaseInfo\ const\&\ testInfo\ )\ override;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_EVENT\_LISTENER\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_HELPERS\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_HELPERS\_HPP\_INCLUDED\#include\ <iosfwd>\#include\ <string>\#include\ <vector>namespace\ Catch\ \{\ \ \ \ class\ IConfig;\ \ \ \ class\ TestCaseHandle;\ \ \ \ class\ ColourImpl;\ \ \ \ //\ Returns\ double\ formatted\ as\ \%.3f\ (format\ expected\ on\ output)\ \ \ \ std::string\ getFormattedDuration(\ double\ duration\ );\ \ \ \ \ \ \ \ bool\ shouldShowDuration(\ IConfig\ const\&\ config,\ double\ duration\ );\ \ \ \ std::string\ serializeFilters(\ std::vector<std::string>\ const\&\ filters\ );\ \ \ \ struct\ lineOfChars\ \{\ \ \ \ \ \ \ \ char\ c;\ \ \ \ \ \ \ \ constexpr\ lineOfChars(\ char\ c\_\ ):\ c(\ c\_\ )\ \{\}\ \ \ \ \ \ \ \ friend\ std::ostream\&\ operator<<(\ std::ostream\&\ out,\ lineOfChars\ value\ );\ \ \ \ \};\ \ \ \ /**\ \ \ \ \ *\ Lists\ reporter\ descriptions\ to\ the\ provided\ stream\ in\ user-\/friendly\ \ \ \ \ *\ format\ \ \ \ \ *\ \ \ \ \ *\ Used\ as\ the\ default\ listing\ implementation\ by\ the\ first\ party\ reporter\ \ \ \ \ *\ bases.\ The\ output\ should\ be\ backwards\ compatible\ with\ the\ output\ of\ \ \ \ \ *\ Catch2\ v2\ binaries.\ \ \ \ \ */\ \ \ \ void\ \ \ \ defaultListReporters(\ std::ostream\&\ out,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<ReporterDescription>\ const\&\ descriptions,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Verbosity\ verbosity\ );\ \ \ \ /**\ \ \ \ \ *\ Lists\ listeners\ descriptions\ to\ the\ provided\ stream\ in\ user-\/friendly\ \ \ \ \ *\ format\ \ \ \ \ */\ \ \ \ void\ defaultListListeners(\ std::ostream\&\ out,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<ListenerDescription>\ const\&\ descriptions\ );\ \ \ \ /**\ \ \ \ \ *\ Lists\ tag\ information\ to\ the\ provided\ stream\ in\ user-\/friendly\ format\ \ \ \ \ *\ \ \ \ \ *\ Used\ as\ the\ default\ listing\ implementation\ by\ the\ first\ party\ reporter\ \ \ \ \ *\ bases.\ The\ output\ should\ be\ backwards\ compatible\ with\ the\ output\ of\ \ \ \ \ *\ Catch2\ v2\ binaries.\ \ \ \ \ */\ \ \ \ void\ defaultListTags(\ std::ostream\&\ out,\ std::vector<TagInfo>\ const\&\ tags,\ bool\ isFiltered\ );\ \ \ \ /**\ \ \ \ \ *\ Lists\ test\ case\ information\ to\ the\ provided\ stream\ in\ user-\/friendly\ \ \ \ \ *\ format\ \ \ \ \ *\ \ \ \ \ *\ Used\ as\ the\ default\ listing\ implementation\ by\ the\ first\ party\ reporter\ \ \ \ \ *\ bases.\ The\ output\ is\ backwards\ compatible\ with\ the\ output\ of\ Catch2\ \ \ \ \ *\ v2\ binaries,\ and\ also\ supports\ the\ format\ specific\ to\ the\ old\ \ \ \ \ *\ \`{}-\/-\/list-\/test-\/names-\/only`\ option,\ for\ people\ who\ used\ it\ in\ integrations.\ \ \ \ \ */\ \ \ \ void\ defaultListTests(\ std::ostream\&\ out,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourImpl*\ streamColour,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<TestCaseHandle>\ const\&\ tests,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ isFiltered,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Verbosity\ verbosity\ );\ \ \ \ /**\ \ \ \ \ *\ Prints\ test\ run\ totals\ to\ the\ provided\ stream\ in\ user-\/friendly\ format\ \ \ \ \ *\ \ \ \ \ *\ Used\ by\ the\ console\ and\ compact\ reporters.\ \ \ \ \ */\ \ \ \ void\ printTestRunTotals(\ std::ostream\&\ stream,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ColourImpl\&\ streamColour,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Totals\ const\&\ totals\ );\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_HELPERS\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_JSON\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_JSON\_HPP\_INCLUDED\#include\ <stack>namespace\ Catch\ \{\ \ \ \ class\ JsonReporter\ :\ public\ StreamingReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ JsonReporter(\ ReporterConfig\&\&\ config\ );\ \ \ \ \ \ \ \ \string~JsonReporter()\ override;\ \ \ \ \ \ \ \ static\ std::string\ getDescription();\ \ \ \ public:\ //\ StreamingReporterBase\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ runInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(\ TestRunStats\ const\&\ runStats\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseStarting(\ TestCaseInfo\ const\&\ tcInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(\ TestCaseStats\ const\&\ tcStats\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialStarting(\ TestCaseInfo\ const\&\ tcInfo,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ index\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialEnded(\ TestCaseStats\ const\&\ tcStats,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ index\ )\ override;\ \ \ \ \ \ \ \ void\ sectionStarting(\ SectionInfo\ const\&\ sectionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(\ SectionStats\ const\&\ sectionStats\ )\ override;\ \ \ \ \ \ \ \ void\ assertionStarting(\ AssertionInfo\ const\&\ assertionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(\ AssertionStats\ const\&\ assertionStats\ )\ override;\ \ \ \ \ \ \ \ //void\ testRunEndedCumulative()\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ name\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ listReporters(\ \ \ \ \ \ \ \ \ \ \ \ std::vector<ReporterDescription>\ const\&\ descriptions\ )\ override;\ \ \ \ \ \ \ \ void\ listListeners(\ \ \ \ \ \ \ \ \ \ \ \ std::vector<ListenerDescription>\ const\&\ descriptions\ )\ override;\ \ \ \ \ \ \ \ void\ listTests(\ std::vector<TestCaseHandle>\ const\&\ tests\ )\ override;\ \ \ \ \ \ \ \ void\ listTags(\ std::vector<TagInfo>\ const\&\ tags\ )\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ Timer\ m\_testCaseTimer;\ \ \ \ \ \ \ \ enum\ class\ Writer\ \{\ \ \ \ \ \ \ \ \ \ \ \ Object,\ \ \ \ \ \ \ \ \ \ \ \ Array\ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ JsonArrayWriter\&\ startArray();\ \ \ \ \ \ \ \ JsonArrayWriter\&\ startArray(\ StringRef\ key\ );\ \ \ \ \ \ \ \ JsonObjectWriter\&\ startObject();\ \ \ \ \ \ \ \ JsonObjectWriter\&\ startObject(\ StringRef\ key\ );\ \ \ \ \ \ \ \ void\ endObject();\ \ \ \ \ \ \ \ void\ endArray();\ \ \ \ \ \ \ \ bool\ isInside(\ Writer\ writer\ );\ \ \ \ \ \ \ \ void\ startListing();\ \ \ \ \ \ \ \ void\ endListing();\ \ \ \ \ \ \ \ //\ Invariant:\ \ \ \ \ \ \ \ //\ When\ m\_writers\ is\ not\ empty\ and\ its\ top\ element\ is\ \ \ \ \ \ \ \ //\ -\/\ Writer::Object,\ then\ m\_objectWriters\ is\ not\ be\ empty\ \ \ \ \ \ \ \ //\ -\/\ Writer::Array,\ \ then\ m\_arrayWriters\ shall\ not\ be\ empty\ \ \ \ \ \ \ \ std::stack<JsonObjectWriter>\ m\_objectWriters\{\};\ \ \ \ \ \ \ \ std::stack<JsonArrayWriter>\ m\_arrayWriters\{\};\ \ \ \ \ \ \ \ std::stack<Writer>\ m\_writers\{\};\ \ \ \ \ \ \ \ bool\ m\_startedListing\ =\ false;\ \ \ \ \ \ \ \ //\ std::size\_t\ m\_sectionDepth\ =\ 0;\ \ \ \ \ \ \ \ //\ std::size\_t\ m\_sectionStarted\ =\ 0;\ \ \ \ \};\}\ //\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_JSON\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_JUNIT\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_JUNIT\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ class\ JunitReporter\ final\ :\ public\ CumulativeReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ JunitReporter(ReporterConfig\&\&\ \_config);\ \ \ \ \ \ \ \ static\ std::string\ getDescription();\ \ \ \ \ \ \ \ void\ testRunStarting(TestRunInfo\ const\&\ runInfo)\ override;\ \ \ \ \ \ \ \ void\ testCaseStarting(TestCaseInfo\ const\&\ testCaseInfo)\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(AssertionStats\ const\&\ assertionStats)\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(TestCaseStats\ const\&\ testCaseStats)\ override;\ \ \ \ \ \ \ \ void\ testRunEndedCumulative()\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ void\ writeRun(TestRunNode\ const\&\ testRunNode,\ double\ suiteTime);\ \ \ \ \ \ \ \ void\ writeTestCase(TestCaseNode\ const\&\ testCaseNode);\ \ \ \ \ \ \ \ void\ writeSection(\ std::string\ const\&\ className,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ const\&\ rootName,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SectionNode\ const\&\ sectionNode,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bool\ testOkToFail\ );\ \ \ \ \ \ \ \ void\ writeAssertions(SectionNode\ const\&\ sectionNode);\ \ \ \ \ \ \ \ void\ writeAssertion(AssertionStats\ const\&\ stats);\ \ \ \ \ \ \ \ XmlWriter\ xml;\ \ \ \ \ \ \ \ Timer\ suiteTimer;\ \ \ \ \ \ \ \ std::string\ stdOutForSuite;\ \ \ \ \ \ \ \ std::string\ stdErrForSuite;\ \ \ \ \ \ \ \ unsigned\ int\ unexpectedExceptions\ =\ 0;\ \ \ \ \ \ \ \ bool\ m\_okToFail\ =\ false;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_JUNIT\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_MULTI\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_MULTI\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ class\ MultiReporter\ final\ :\ public\ IEventListener\ \{\ \ \ \ \ \ \ \ /*\ \ \ \ \ \ \ \ \ *\ Stores\ all\ added\ reporters\ and\ listeners\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ \ *\ All\ Listeners\ are\ stored\ before\ all\ reporters,\ and\ individual\ \ \ \ \ \ \ \ \ *\ listeners/reporters\ are\ stored\ in\ order\ of\ insertion.\ \ \ \ \ \ \ \ \ */\ \ \ \ \ \ \ \ std::vector<IEventListenerPtr>\ m\_reporterLikes;\ \ \ \ \ \ \ \ bool\ m\_haveNoncapturingReporters\ =\ false;\ \ \ \ \ \ \ \ //\ Keep\ track\ of\ how\ many\ listeners\ we\ have\ already\ inserted,\ \ \ \ \ \ \ \ //\ so\ that\ we\ can\ insert\ them\ into\ the\ main\ vector\ at\ the\ right\ place\ \ \ \ \ \ \ \ size\_t\ m\_insertedListeners\ =\ 0;\ \ \ \ \ \ \ \ void\ updatePreferences(IEventListener\ const\&\ reporterish);\ \ \ \ public:\ \ \ \ \ \ \ \ using\ IEventListener::IEventListener;\ \ \ \ \ \ \ \ void\ addListener(\ IEventListenerPtr\&\&\ listener\ );\ \ \ \ \ \ \ \ void\ addReporter(\ IEventListenerPtr\&\&\ reporter\ );\ \ \ \ public:\ //\ IEventListener\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ unmatchedSpec\ )\ override;\ \ \ \ \ \ \ \ void\ fatalErrorEncountered(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ reportInvalidTestSpec(\ StringRef\ arg\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ name\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkStarting(\ BenchmarkInfo\ const\&\ benchmarkInfo\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkEnded(\ BenchmarkStats<>\ const\&\ benchmarkStats\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ testRunInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testCaseStarting(\ TestCaseInfo\ const\&\ testInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialStarting(TestCaseInfo\ const\&\ testInfo,\ uint64\_t\ partNumber)\ override;\ \ \ \ \ \ \ \ void\ sectionStarting(\ SectionInfo\ const\&\ sectionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ assertionStarting(\ AssertionInfo\ const\&\ assertionInfo\ )\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(\ AssertionStats\ const\&\ assertionStats\ )\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(\ SectionStats\ const\&\ sectionStats\ )\ override;\ \ \ \ \ \ \ \ void\ testCasePartialEnded(TestCaseStats\ const\&\ testStats,\ uint64\_t\ partNumber)\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(\ TestCaseStats\ const\&\ testCaseStats\ )\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(\ TestRunStats\ const\&\ testRunStats\ )\ override;\ \ \ \ \ \ \ \ void\ skipTest(\ TestCaseInfo\ const\&\ testInfo\ )\ override;\ \ \ \ \ \ \ \ void\ listReporters(std::vector<ReporterDescription>\ const\&\ descriptions)\ override;\ \ \ \ \ \ \ \ void\ listListeners(std::vector<ListenerDescription>\ const\&\ descriptions)\ override;\ \ \ \ \ \ \ \ void\ listTests(std::vector<TestCaseHandle>\ const\&\ tests)\ override;\ \ \ \ \ \ \ \ void\ listTags(std::vector<TagInfo>\ const\&\ tags)\ override;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_MULTI\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_REGISTRARS\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_REGISTRARS\_HPP\_INCLUDED\#include\ <type\_traits>namespace\ Catch\ \{\ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ template\ <typename\ T,\ typename\ =\ void>\ \ \ \ \ \ \ \ struct\ has\_description\ :\ std::false\_type\ \{\};\ \ \ \ \ \ \ \ template\ <typename\ T>\ \ \ \ \ \ \ \ struct\ has\_description<\ \ \ \ \ \ \ \ \ \ \ \ T,\ \ \ \ \ \ \ \ \ \ \ \ void\_t<decltype(\ T::getDescription()\ )>>\ \ \ \ \ \ \ \ \ \ \ \ :\ std::true\_type\ \{\};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ registerReporterImpl(\ std::string\ const\&\ name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IReporterFactoryPtr\ reporterPtr\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ registerListenerImpl(\ Detail::unique\_ptr<EventListenerFactory>\ listenerFactory\ );\ \ \ \ \}\ //\ namespace\ Detail\ \ \ \ class\ IEventListener;\ \ \ \ using\ IEventListenerPtr\ =\ Detail::unique\_ptr<IEventListener>;\ \ \ \ template\ <typename\ T>\ \ \ \ class\ ReporterFactory\ :\ public\ IReporterFactory\ \{\ \ \ \ \ \ \ \ IEventListenerPtr\ create(\ ReporterConfig\&\&\ config\ )\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ Detail::make\_unique<T>(\ CATCH\_MOVE(config)\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ std::string\ getDescription()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ return\ T::getDescription();\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ template<typename\ T>\ \ \ \ class\ ReporterRegistrar\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ explicit\ ReporterRegistrar(\ std::string\ const\&\ name\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ registerReporterImpl(\ name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Detail::make\_unique<ReporterFactory<T>>()\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \};\ \ \ \ template<typename\ T>\ \ \ \ class\ ListenerRegistrar\ \{\ \ \ \ \ \ \ \ class\ TypedListenerFactory\ :\ public\ EventListenerFactory\ \{\ \ \ \ \ \ \ \ \ \ \ \ StringRef\ m\_listenerName;\ \ \ \ \ \ \ \ \ \ \ \ std::string\ getDescriptionImpl(\ std::true\_type\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ T::getDescription();\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ getDescriptionImpl(\ std::false\_type\ )\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}(No\ description\ provided)"{};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ TypedListenerFactory(\ StringRef\ listenerName\ ):\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_listenerName(\ listenerName\ )\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ IEventListenerPtr\ create(\ IConfig\ const*\ config\ )\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ Detail::make\_unique<T>(\ config\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ StringRef\ getName()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ m\_listenerName;\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ std::string\ getDescription()\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ getDescriptionImpl(\ Detail::has\_description<T>\{\}\ );\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \};\ \ \ \ public:\ \ \ \ \ \ \ \ ListenerRegistrar(StringRef\ listenerName)\ \{\ \ \ \ \ \ \ \ \ \ \ \ registerListenerImpl(\ Detail::make\_unique<TypedListenerFactory>(listenerName)\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \};\}\#if\ !defined(CATCH\_CONFIG\_DISABLE)\#\ \ \ \ define\ CATCH\_REGISTER\_REPORTER(\ name,\ reporterType\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ namespace\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ Catch::ReporterRegistrar<reporterType>\ INTERNAL\_CATCH\_UNIQUE\_NAME(\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ catch\_internal\_RegistrarFor\ )(\ name\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION\#\ \ \ \ define\ CATCH\_REGISTER\_LISTENER(\ listenerType\ )\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ namespace\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ Catch::ListenerRegistrar<listenerType>\ INTERNAL\_CATCH\_UNIQUE\_NAME(\ \(\backslash\)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ catch\_internal\_RegistrarFor\ )(\ \#listenerType\#\#\_catch\_sr\ );\ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)\ \ \ \ \ \ \ \ CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION\#else\ //\ CATCH\_CONFIG\_DISABLE\#define\ CATCH\_REGISTER\_REPORTER(name,\ reporterType)\#define\ CATCH\_REGISTER\_LISTENER(listenerType)\#endif\ //\ CATCH\_CONFIG\_DISABLE\#endif\ //\ CATCH\_REPORTER\_REGISTRARS\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_SONARQUBE\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_SONARQUBE\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ class\ SonarQubeReporter\ final\ :\ public\ CumulativeReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ SonarQubeReporter(ReporterConfig\&\&\ config)\ \ \ \ \ \ \ \ :\ CumulativeReporterBase(CATCH\_MOVE(config))\ \ \ \ \ \ \ \ ,\ xml(m\_stream)\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_preferences.shouldRedirectStdOut\ =\ true;\ \ \ \ \ \ \ \ \ \ \ \ m\_preferences.shouldReportAllAssertions\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ m\_shouldStoreSuccesfulAssertions\ =\ false;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ static\ std::string\ getDescription()\ \{\ \ \ \ \ \ \ \ \ \ \ \ using\ namespace\ std::string\_literals;\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Reports\ test\ results\ in\ the\ Generic\ Test\ Data\ SonarQube\ XML\ format"{}s;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ testRunInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testRunEndedCumulative()\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ writeRun(\ *m\_testRun\ );\ \ \ \ \ \ \ \ \ \ \ \ xml.endElement();\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ writeRun(\ TestRunNode\ const\&\ runNode\ );\ \ \ \ \ \ \ \ void\ writeTestFile(StringRef\ filename,\ std::vector<TestCaseNode\ const*>\ const\&\ testCaseNodes);\ \ \ \ \ \ \ \ void\ writeTestCase(TestCaseNode\ const\&\ testCaseNode);\ \ \ \ \ \ \ \ void\ writeSection(std::string\ const\&\ rootName,\ SectionNode\ const\&\ sectionNode,\ bool\ okToFail);\ \ \ \ \ \ \ \ void\ writeAssertions(SectionNode\ const\&\ sectionNode,\ bool\ okToFail);\ \ \ \ \ \ \ \ void\ writeAssertion(AssertionStats\ const\&\ stats,\ bool\ okToFail);\ \ \ \ private:\ \ \ \ \ \ \ \ XmlWriter\ xml;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_SONARQUBE\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_TAP\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_TAP\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ class\ TAPReporter\ final\ :\ public\ StreamingReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ TAPReporter(\ ReporterConfig\&\&\ config\ ):\ \ \ \ \ \ \ \ \ \ \ \ StreamingReporterBase(\ CATCH\_MOVE(config)\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_preferences.shouldReportAllAssertions\ =\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ static\ std::string\ getDescription()\ \{\ \ \ \ \ \ \ \ \ \ \ \ using\ namespace\ std::string\_literals;\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Reports\ test\ results\ in\ TAP\ format,\ suitable\ for\ test\ harnesses"{}s;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ testInfo\ )\ override;\ \ \ \ \ \ \ \ void\ noMatchingTestCases(\ StringRef\ unmatchedSpec\ )\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(AssertionStats\ const\&\ \_assertionStats)\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(TestRunStats\ const\&\ \_testRunStats)\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ std::size\_t\ counter\ =\ 0;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_TAP\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_TEAMCITY\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_TEAMCITY\_HPP\_INCLUDED\#include\ <cstring>\#ifdef\ \_\_clang\_\_\#\ \ \ pragma\ clang\ diagnostic\ push\#\ \ \ pragma\ clang\ diagnostic\ ignored\ "{}-\/Wpadded"{}\#endifnamespace\ Catch\ \{\ \ \ \ class\ TeamCityReporter\ final\ :\ public\ StreamingReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ TeamCityReporter(\ ReporterConfig\&\&\ \_config\ )\ \ \ \ \ \ \ \ :\ \ \ StreamingReporterBase(\ CATCH\_MOVE(\_config)\ )\ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_preferences.shouldRedirectStdOut\ =\ true;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \string~TeamCityReporter()\ override;\ \ \ \ \ \ \ \ static\ std::string\ getDescription()\ \{\ \ \ \ \ \ \ \ \ \ \ \ using\ namespace\ std::string\_literals;\ \ \ \ \ \ \ \ \ \ \ \ return\ "{}Reports\ test\ results\ as\ TeamCity\ service\ messages"{}s;\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testRunStarting(\ TestRunInfo\ const\&\ runInfo\ )\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(\ TestRunStats\ const\&\ runStats\ )\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(AssertionStats\ const\&\ assertionStats)\ override;\ \ \ \ \ \ \ \ void\ sectionStarting(SectionInfo\ const\&\ sectionInfo)\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ m\_headerPrintedForThisSection\ =\ false;\ \ \ \ \ \ \ \ \ \ \ \ StreamingReporterBase::sectionStarting(\ sectionInfo\ );\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ void\ testCaseStarting(TestCaseInfo\ const\&\ testInfo)\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(TestCaseStats\ const\&\ testCaseStats)\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ void\ printSectionHeader(std::ostream\&\ os);\ \ \ \ \ \ \ \ bool\ m\_headerPrintedForThisSection\ =\ false;\ \ \ \ \ \ \ \ Timer\ m\_testTimer;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#ifdef\ \_\_clang\_\_\#\ \ \ pragma\ clang\ diagnostic\ pop\#endif\#endif\ //\ CATCH\_REPORTER\_TEAMCITY\_HPP\_INCLUDED\#ifndef\ CATCH\_REPORTER\_XML\_HPP\_INCLUDED\#define\ CATCH\_REPORTER\_XML\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ class\ XmlReporter\ :\ public\ StreamingReporterBase\ \{\ \ \ \ public:\ \ \ \ \ \ \ \ XmlReporter(ReporterConfig\&\&\ \_config);\ \ \ \ \ \ \ \ \string~XmlReporter()\ override;\ \ \ \ \ \ \ \ static\ std::string\ getDescription();\ \ \ \ \ \ \ \ virtual\ std::string\ getStylesheetRef()\ const;\ \ \ \ \ \ \ \ void\ writeSourceInfo(SourceLineInfo\ const\&\ sourceInfo);\ \ \ \ public:\ //\ StreamingReporterBase\ \ \ \ \ \ \ \ void\ testRunStarting(TestRunInfo\ const\&\ testInfo)\ override;\ \ \ \ \ \ \ \ void\ testCaseStarting(TestCaseInfo\ const\&\ testInfo)\ override;\ \ \ \ \ \ \ \ void\ sectionStarting(SectionInfo\ const\&\ sectionInfo)\ override;\ \ \ \ \ \ \ \ void\ assertionStarting(AssertionInfo\ const\&)\ override;\ \ \ \ \ \ \ \ void\ assertionEnded(AssertionStats\ const\&\ assertionStats)\ override;\ \ \ \ \ \ \ \ void\ sectionEnded(SectionStats\ const\&\ sectionStats)\ override;\ \ \ \ \ \ \ \ void\ testCaseEnded(TestCaseStats\ const\&\ testCaseStats)\ override;\ \ \ \ \ \ \ \ void\ testRunEnded(TestRunStats\ const\&\ testRunStats)\ override;\ \ \ \ \ \ \ \ void\ benchmarkPreparing(\ StringRef\ name\ )\ override;\ \ \ \ \ \ \ \ void\ benchmarkStarting(BenchmarkInfo\ const\&)\ override;\ \ \ \ \ \ \ \ void\ benchmarkEnded(BenchmarkStats<>\ const\&)\ override;\ \ \ \ \ \ \ \ void\ benchmarkFailed(\ StringRef\ error\ )\ override;\ \ \ \ \ \ \ \ void\ listReporters(std::vector<ReporterDescription>\ const\&\ descriptions)\ override;\ \ \ \ \ \ \ \ void\ listListeners(std::vector<ListenerDescription>\ const\&\ descriptions)\ override;\ \ \ \ \ \ \ \ void\ listTests(std::vector<TestCaseHandle>\ const\&\ tests)\ override;\ \ \ \ \ \ \ \ void\ listTags(std::vector<TagInfo>\ const\&\ tags)\ override;\ \ \ \ private:\ \ \ \ \ \ \ \ Timer\ m\_testCaseTimer;\ \ \ \ \ \ \ \ XmlWriter\ m\_xml;\ \ \ \ \ \ \ \ int\ m\_sectionDepth\ =\ 0;\ \ \ \ \};\}\ //\ end\ namespace\ Catch\#endif\ //\ CATCH\_REPORTER\_XML\_HPP\_INCLUDED\#endif\ //\ CATCH\_REPORTERS\_ALL\_HPP\_INCLUDED\#endif\ //\ CATCH\_ALL\_HPP\_INCLUDED\#endif\ //\ CATCH\_AMALGAMATED\_HPP\_INCLUDEDuccessful\ assertions,\ or\ because\ the\ deriving\ reporter\ does\ not\ use\ asse\#ifndef\ CATCH\_WINDOWS\_H\_PROXY\_HPP\_INCLUDED\#define\ CATCH\_WINDOWS\_H\_PROXY\_HPP\_INCLUDED\#if\ defined(CATCH\_PLATFORM\_WINDOWS)//\ We\ might\ end\ up\ with\ the\ define\ made\ globally\ through\ the\ compiler,//\ and\ we\ don't\ want\ to\ trigger\ warnings\ for\ this\#if\ !defined(NOMINMAX)\#\ \ define\ NOMINMAX\#endif\#if\ !defined(WIN32\_LEAN\_AND\_MEAN)\#\ \ define\ WIN32\_LEAN\_AND\_MEAN\#endif\#include\ <windows.h>\#endif\ //\ defined(CATCH\_PLATFORM\_WINDOWS)\#endif\ //\ CATCH\_WINDOWS\_H\_PROXY\_HPP\_INCLUDEDnamespace\ Catch\ \{\ \ \ \ namespace\ Benchmark\ \{\ \ \ \ \ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ ChronometerConcept::\string~ChronometerConcept()\ =\ default;\ \ \ \ \ \ \ \ \}\ //\ namespace\ Detail\ \ \ \ \}\ //\ namespace\ Benchmark\}\ //\ namespace\ Catch//\ Adapted\ from\ donated\ nonius\ code.\#include\ <vector>namespace\ Catch\ \{\ \ \ \ namespace\ Benchmark\ \{\ \ \ \ \ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ SampleAnalysis\ analyse(const\ IConfig\ \&cfg,\ FDuration*\ first,\ FDuration*\ last)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (!cfg.benchmarkNoAnalysis())\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<double>\ samples;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.reserve(static\_cast<size\_t>(last\ -\/\ first));\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\ current\ =\ first;\ current\ !=\ last;\ ++current)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.push\_back(\ current-\/>count()\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ analysis\ =\ Catch::Benchmark::Detail::analyse\_samples(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cfg.benchmarkConfidenceInterval(),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cfg.benchmarkResamples(),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.data(),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.data()\ +\ samples.size()\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ outliers\ =\ Catch::Benchmark::Detail::classify\_outliers(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.data(),\ samples.data()\ +\ samples.size()\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ wrap\_estimate\ =\ [](Estimate<double>\ e)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ Estimate<FDuration>\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FDuration(e.point),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FDuration(e.lower\_bound),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FDuration(e.upper\_bound),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e.confidence\_interval,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<FDuration>\ samples2;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples2.reserve(samples.size());\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\ s\ :\ samples)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples2.push\_back(\ FDuration(\ s\ )\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CATCH\_MOVE(samples2),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ wrap\_estimate(analysis.mean),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ wrap\_estimate(analysis.standard\_deviation),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ outliers,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ analysis.outlier\_variance,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ else\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<FDuration>\ samples;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.reserve(static\_cast<size\_t>(last\ -\/\ first));\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FDuration\ mean\ =\ FDuration(0);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int\ i\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (auto\ it\ =\ first;\ it\ <\ last;\ ++it,\ ++i)\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ samples.push\_back(*it);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mean\ +=\ *it;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mean\ /=\ i;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ SampleAnalysis\{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CATCH\_MOVE(samples),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Estimate<FDuration>\{\ mean,\ mean,\ mean,\ 0.0\ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Estimate<FDuration>\{\ FDuration(\ 0\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FDuration(\ 0\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FDuration(\ 0\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.0\ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OutlierClassification\{\},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0.0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \}\ //\ namespace\ Detail\ \ \ \ \}\ //\ namespace\ Benchmark\}\ //\ namespace\ Catchnamespace\ Catch\ \{\ \ \ \ namespace\ Benchmark\ \{\ \ \ \ \ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ struct\ do\_nothing\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ void\ operator()()\ const\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ BenchmarkFunction::callable::\string~callable()\ =\ default;\ \ \ \ \ \ \ \ \ \ \ \ BenchmarkFunction::BenchmarkFunction():\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ f(\ new\ model<do\_nothing>\{\ \{\}\ \}\ )\{\}\ \ \ \ \ \ \ \ \}\ //\ namespace\ Detail\ \ \ \ \}\ //\ namespace\ Benchmark\}\ //\ namespace\ Catch\#include\ <exception>namespace\ Catch\ \{\ \ \ \ namespace\ Benchmark\ \{\ \ \ \ \ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ struct\ optimized\_away\_error\ :\ std::exception\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ char*\ what()\ const\ noexcept\ override;\ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ const\ char*\ optimized\_away\_error::what()\ const\ noexcept\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ "{}could\ not\ measure\ benchmark,\ maybe\ it\ was\ optimized\ away"{};\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ void\ throw\_optimized\_away\_error()\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Catch::throw\_exception(optimized\_away\_error\{\});\ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \}\ //\ namespace\ Detail\ \ \ \ \}\ //\ namespace\ Benchmark\}\ //\ namespace\ Catch//\ Adapted\ from\ donated\ nonius\ code.\#include\ <algorithm>\#include\ <cassert>\#include\ <cmath>\#include\ <cstddef>\#include\ <numeric>\#include\ <random>\#if\ defined(CATCH\_CONFIG\_USE\_ASYNC)\#include\ <future>\#endifnamespace\ Catch\ \{\ \ \ \ namespace\ Benchmark\ \{\ \ \ \ \ \ \ \ namespace\ Detail\ \{\ \ \ \ \ \ \ \ \ \ \ \ namespace\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ template\ <typename\ URng,\ typename\ Estimator>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\ sample\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ resample(\ URng\&\ rng,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unsigned\ int\ resamples,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ const*\ first,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ const*\ last,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Estimator\&\ estimator\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ n\ =\ static\_cast<size\_t>(\ last\ -\/\ first\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Catch::uniform\_integer\_distribution<size\_t>\ dist(\ 0,\ n\ -\/\ 1\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sample\ out;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ out.reserve(\ resamples\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<double>\ resampled;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ resampled.reserve(\ n\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (\ size\_t\ i\ =\ 0;\ i\ <\ resamples;\ ++i\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ resampled.clear();\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (\ size\_t\ s\ =\ 0;\ s\ <\ n;\ ++s\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ resampled.push\_back(\ first[dist(\ rng\ )]\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ auto\ estimate\ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ estimator(\ resampled.data(),\ resampled.data()\ +\ resampled.size()\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ out.push\_back(\ estimate\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::sort(\ out.begin(),\ out.end()\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ out;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\ double\ outlier\_variance(\ Estimate<double>\ mean,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Estimate<double>\ stddev,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int\ n\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ sb\ =\ stddev.point;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ mn\ =\ mean.point\ /\ n;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ mg\_min\ =\ mn\ /\ 2.;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ sg\ =\ (std::min)(\ mg\_min\ /\ 4.,\ sb\ /\ std::sqrt(\ n\ )\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ sg2\ =\ sg\ *\ sg;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ sb2\ =\ sb\ *\ sb;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ c\_max\ =\ [n,\ mn,\ sb2,\ sg2](\ double\ x\ )\ -\/>\ double\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ k\ =\ mn\ -\/\ x;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ d\ =\ k\ *\ k;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ nd\ =\ n\ *\ d;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ k0\ =\ -\/n\ *\ nd;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ k1\ =\ sb2\ -\/\ n\ *\ sg2\ +\ nd;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ det\ =\ k1\ *\ k1\ -\/\ 4\ *\ sg2\ *\ k0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ static\_cast<int>(\ -\/2.\ *\ k0\ /\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\ k1\ +\ std::sqrt(\ det\ )\ )\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ auto\ var\_out\ =\ [n,\ sb2,\ sg2](\ double\ c\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double\ nc\ =\ n\ -\/\ c;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ (\ nc\ /\ n\ )\ *\ (\ sb2\ -\/\ nc\ *\ sg2\ );\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ (std::min)(\ var\_out(\ 1\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ var\_out(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (std::min)(\ c\_max(\ 0.\ ),\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ c\_max(\ mg\_min\ )\ )\ )\ )\ /\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sb2;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\ double\ erf\_inv(\ double\ x\ )\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ Code\ accompanying\ the\ article\ "{}Approximating\ the\ erfinv}}

\end{DoxyCode}


\label{doc-func-members}
\Hypertarget{catch__amalgamated_8cpp_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!if@{if}}
\index{if@{if}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{if()}{if()}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed} 
\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} if (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\Hypertarget{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!main@{main}}
\index{main@{main}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97} 
int main (\begin{DoxyParamCaption}\item[{int}]{argc}{, }\item[{char \texorpdfstring{$\ast$}{*}}]{argv}{\mbox{[}$\,$\mbox{]}}\end{DoxyParamCaption})}



\label{doc-var-members}
\Hypertarget{catch__amalgamated_8cpp_doc-var-members}
\doxysubsection{Variable Documentation}
\Hypertarget{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!else@{else}}
\index{else@{else}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{else}{else}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba} 
else}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}}\ =\ sqrt(\ \mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}}\ )\ -\/\ 5.000000}

\end{DoxyCode}
\Hypertarget{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!p@{p}}
\index{p@{p}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{p}{p}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c} 
p = -\/2.\+7109920616438573243e-\/11}

\Hypertarget{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!w@{w}}
\index{w@{w}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{w}{w}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3} 
w = -\/log( ( 1.\+0 -\/ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) \texorpdfstring{$\ast$}{*} ( 1.\+0 + \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) )}

\Hypertarget{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!x@{x}}
\index{x@{x}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{x}{x}}
{\footnotesize\ttfamily \label{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265} 
return \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}}\texorpdfstring{$\ast$}{*} x}

